Conditions:
  CreateAlarms: !Not
    - !Equals
      - ''
      - !Ref 'SNSTopicArn'
  CreateEndpointRecord: !And
    - !Condition 'IsAcceptorStack'
    - !Condition 'HostedZoneSupplied'
    - !Condition 'FIXServerDNSNameSupplied'
  FIXServerDNSNameSupplied: !Not
    - !Equals
      - ''
      - !Ref 'FIXServerDNSName'
  HostedZoneSupplied: !Not
    - !Equals
      - ''
      - !Ref 'HostedZoneID'
  IsAcceptorStack: !Equals
    - acceptor
    - !Ref 'ConnectionType'
  IsInitiatorStack: !Equals
    - initiator
    - !Ref 'ConnectionType'
  KMSKeySupplied: !Not
    - !Equals
      - ''
      - !Ref 'KMSKeyARN'
  SendLogsToS3: !Not
    - !Equals
      - ''
      - !Ref 'S3LogsBucket'
  UseDefaultImage: !Equals
    - ''
    - !Ref 'CustomImagePath'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Application
        Parameters:
          - GitHubRepoUrl
          - GitHubRepoBranch
      - Label:
          default: FIX Configuration
        Parameters:
          - FIXVersion
          - FIXServerPort
          - ConnectionType
          - DebugLogging
          - TargetCompID
          - SenderCompID
          - ApplicationID
          - CustomImagePath
      - Label:
          default: Networking
        Parameters:
          - VPC
          - PrimaryPublicSubnet
          - FailoverPublicSubnet
          - PrimaryPrivateSubnet
          - FailoverPrivateSubnet
      - Label:
          default: Security
        Parameters:
          - KMSKeyARN
          - FIXClientCIDRs
          - UserApplicationCIDRs
      - Label:
          default: Accessibility
        Parameters:
          - HostedZoneID
          - FIXServerDNSName
      - Label:
          default: Logging, Monitoring & Alerting
        Parameters:
          - S3LogsBucket
          - S3LogsBucketPrefix
          - SNSTopicArn
          - LogRetentionInDays
    ParameterLabels:
      CustomImagePath:
        default: Image Path
      FIXClientCIDRs:
        default: FIX Client CIDRs
      FIXServerDNSName:
        default: FIX Server DNS Name
      FIXVersion:
        default: FIX Version
      FailoverAvailabilityZoneLetter:
        default: Failover AZ Letter
      FailoverPrivateSubnet:
        default: Failover Private Subnet
      FailoverPrivateSubnetCIDR:
        default: Failover Private Subnet CIDR
      FailoverPublicSubnet:
        default: Failover Public Subnet
      FailoverPublicSubnetCIDR:
        default: Failover Public Subnet CIDR
      GitHubRepoBranch:
        default: GitHub Repo Branch
      GitHubRepoUrl:
        default: GitHub Repo URL
      HostedZoneID:
        default: Hosted Zone
      KMSKeyARN:
        default: KMS Key ARN
      LogRetentionInDays:
        default: Log Retention in Days
      PrimaryAvailabilityZoneLetter:
        default: Primary AZ Letter
      PrimaryPrivateSubnet:
        default: Primary Private Subnet
      PrimaryPrivateSubnetCIDR:
        default: Primary Private Subnet CIDR
      PrimaryPublicSubnet:
        default: Primary Public Subnet
      PrimaryPublicSubnetCIDR:
        default: Primary Public Subnet CIDR
      S3LogsBucket:
        default: Logs Bucket
      S3LogsBucketPrefix:
        default: Logs Bucket Prefix
      SNSTopicArn:
        default: Target SNS Topic
      UserApplicationCIDRs:
        default: User Application CIDRs
      VPC:
        default: VPC
      VpcCIDR:
        default: VPC CIDR
  Comments: ''
  CreatedBy: Carter Meyers (AWS)
  Description: This application deploys a highly resilient FIX Engine application on AWS.
  LastUpdated: March 20, 2023
  Version: v2.0
Outputs:
  ApplicationID:
    Condition: ''
    Value: !Ref 'ApplicationID'
  ConnectionType:
    Condition: ''
    Value: !Ref 'ConnectionType'
  DatabaseName:
    Condition: ''
    Value: !Join
      - ''
      - - quickfix-
        - !Select
          - 2
          - !Split
            - /
            - !Ref 'AWS::StackId'
        - ;
  DebugLogging:
    Condition: ''
    Value: !Ref 'DebugLogging'
  FIXServerDNSName:
    Condition: ''
    Value: !If
      - FIXServerDNSNameSupplied
      - !Ref 'FIXServerDNSName'
      - None
  FIXServerPort:
    Condition: ''
    Value: !Ref 'FIXServerPort'
  FIXVersion:
    Condition: ''
    Value: !Ref 'FIXVersion'
  FIXVersionInt:
    Condition: ''
    Value: !Join
      - ''
      - !Split
        - .
        - !Ref 'FIXVersion'
  GlobalAcceleratorArn:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAccelerator.AcceleratorArn'
  GlobalAcceleratorDNSName:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAccelerator.DnsName'
  GlobalAcceleratorEndpointGroupArn:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
  GlobalAcceleratorIPAddresses:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAcceleratorInfoRetrieverResource.IPAddresses'
  MemoryDBHost:
    Condition: ''
    Value: !GetAtt 'MemoryDbCluster.ClusterEndpoint.Address'
  MemoryDBPort:
    Condition: ''
    Value: '6379'
  SenderCompID:
    Condition: ''
    Value: !Ref 'SenderCompID'
  TargetCompID:
    Condition: ''
    Value: !Ref 'TargetCompID'
Parameters:
  ApplicationID:
    Default: server
    Description: ''
    Type: String
  ConnectionType:
    AllowedValues:
      - acceptor
      - initiator
    Default: acceptor
    Description: The engine role to be deployed - acceptor for server, initiator for client
    Type: String
  CustomImagePath:
    Default: ''
    Description: "[Optional] This CloudFormation stack will create a Docker image to be used by ECS. If you wish to use your own image, specify the path here. \n            Up to 255 letters (uppercase\
      \ and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed."
    Type: String
  DebugLogging:
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'
    Description: ''
    Type: String
  FIXClientCIDRs:
    Default: 10.10.0.0/20
    Description: The comma-delimited external CIDR ranges that should be granted access to your ingestion endpoint. (Max. 5)
    Type: CommaDelimitedList
  FIXServerDNSName:
    Default: ''
    Description: If you are the acceptor, this will be the domain name created that points to your Global Accelerator Endpoint (e.g., fix.example.com)
    Type: String
  FIXServerPort:
    Default: 9877
    Description: Port number used to create FIX connection.
    MaxValue: 65535
    MinValue: 1
    Type: Number
  FIXVersion:
    AllowedValues:
      - '4.0'
      - '4.1'
      - '4.2'
      - '4.3'
      - '4.4'
      - '5.0'
    Default: '4.2'
    Description: The desired FIX engine version.
    Type: String
  FailoverPrivateSubnet:
    Description: The private subnet you wish to use for your failover compute and data resources.
    Type: AWS::EC2::Subnet::Id
  FailoverPublicSubnet:
    Description: The public subnet you wish to use for your failover Network Load Balancer.
    Type: AWS::EC2::Subnet::Id
  GitHubRepoBranch:
    Default: '2.0'
    Description: The branch of the above GitHub repo to use for the Docker container build.
    Type: String
  GitHubRepoUrl:
    Default: https://github.com/aws-samples/amazon-resilient-fix-engine-demo.git
    Description: The GitHub repo containing the code used to build the Fargate Docker container.
    Type: String
  HostedZoneID:
    Default: ''
    Description: '[Required for Acceptor Stack] If you are the acceptor, this should be the Hosted Zone ID for the domain hosted in Route53.'
    Type: String
  KMSKeyARN:
    Default: ''
    Description: >-
      [Optional] The ARN of the KMS key you wish to use for data encrypion. Warning: Adding or changing the KMS key once the stack has been deployed may require resources to be recreated, and may thus result
      in data loss.
    Type: String
  LogRetentionInDays:
    AllowedValues:
      - '1'
      - '7'
      - '14'
      - '30'
      - '60'
      - '90'
      - '120'
      - '180'
      - '365'
    Default: '30'
    Description: The number of days CloudWatch-bound application logs should be kept.
    Type: String
  PrimaryPrivateSubnet:
    Description: The private subnet you wish to use for your primary compute and data resources.
    Type: AWS::EC2::Subnet::Id
  PrimaryPublicSubnet:
    Description: The public subnet you wish to use for your primary Network Load Balancer.
    Type: AWS::EC2::Subnet::Id
  S3LogsBucket:
    Default: ''
    Description: >-
      [Optional] The S3 Bucket you wish to use for S3-bound application logs (e.g., Network Load Balancer). Please ensure your bucket policy is configured to allow delivery from your NLBs: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-logging-bucket-permissions
    Type: String
  S3LogsBucketPrefix:
    Default: ''
    Description: '[Optional] The S3 Key prefix you wish to use for S3-bound application logs.'
    Type: String
  SNSTopicArn:
    Default: ''
    Description: '[Optional] The SNS Topic ARN you would like alerts sent to related to the resources in this stack.'
    Type: String
  SenderCompID:
    Default: server
    Description: ''
    Type: String
  TargetCompID:
    Default: client
    Description: Computer ID used to initiate FIX communication
    Type: String
  UserApplicationCIDRs:
    Default: 10.10.0.0/20
    Description: The comma-delimited private CIDR ranges corresponding to the user application that should be granted access to your MSK endpoint. (Max. 5)
    Type: CommaDelimitedList
  VPC:
    Description: The VPC into which these resources should be launched.
    Type: AWS::EC2::VPC::Id
Resources:
  ApplicationIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX Application ID for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - ApplicationID
      Tier: Standard
      Type: String
      Value: !Ref 'ApplicationID'
    Type: AWS::SSM::Parameter
  AutomationDocumentStarter:
    DependsOn:
      - AutomationDocumentStarterRole
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: "import json\nimport time\nimport boto3\nimport logging\nimport cfnresponse\nfrom botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\n\
          logging.getLogger('boto3').setLevel(logging.INFO)\nlogging.getLogger('botocore').setLevel(logging.INFO)\n\nssm_client = boto3.client('ssm')\n\ndef start_document(properties):\n    \n    try:\n\
          \        \n        response = ssm_client.start_automation_execution(\n            Parameters = {\n                'ExecutionRoleArn': [\n                    properties['ExecutionRoleArn']\n  \
          \              ]\n            },\n            DocumentName = properties['AutomationDocumentName'],\n        )\n    \n        return True\n    \n    except ClientError as e:\n        print(str(e));\
          \ return False\n\n'''\n    - ExecutionRoleArn | str\n    - EligibleRequestTypes | list\n    - AutomationDocumentName | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST\
          \ RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n    \n    responseData = {}\n\n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n    properties = event['ResourceProperties']['Properties']\n\
          \    \n    if 'EligibleRequestTypes' not in properties:\n        properties['EligibleRequestTypes'] = ['Create']\n    \n    if event['RequestType'] in properties['EligibleRequestTypes']:\n   \
          \     \n        attempt_cnt = 0\n        while attempt_cnt < 5:\n            \n            if attempt_cnt > 0:\n                time.sleep(10)\n            \n            if start_document(properties)\
          \ is True:\n                return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, properties['AutomationDocumentName'])\n        \n            attempt_cnt += 1\n         \
          \   \n        return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n    \n    elif event['RequestType'] not in properties['EligibleRequestTypes']:\n        \n        return\
          \ cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)"
      Description: ''
      Handler: index.handler
      Layers: []
      MemorySize: 128
      Role: !GetAtt 'AutomationDocumentStarterRole.Arn'
      Runtime: python3.9
      Timeout: 180
      TracingConfig:
        Mode: PassThrough
    Type: AWS::Lambda::Function
  AutomationDocumentStarterLogGroup:
    DeletionPolicy: Delete
    DependsOn:
      - AutomationDocumentStarter
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'AutomationDocumentStarter'
      RetentionInDays: 30
    Type: AWS::Logs::LogGroup
  AutomationDocumentStarterRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      MaxSessionDuration: 3600
      Policies: []
    Type: AWS::IAM::Role
  AutomationDocumentStarterRoleECSImageBuildPolicy:
    DependsOn:
      - AutomationDocumentStarterRole
      - ECSImageBuildDocument
      - ECSImageBuildExecutionRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt 'ECSImageBuildExecutionRole.Arn'
          - Action:
              - ssm:StartAutomationExecution
            Effect: Allow
            Resource:
              - !Join
                - ''
                - - 'arn:aws:ssm:'
                  - !Ref 'AWS::Region'
                  - ':'
                  - !Ref 'AWS::AccountId'
                  - :automation-definition/
                  - !Ref 'ECSImageBuildDocument'
                  - :$DEFAULT
      PolicyName: ECSImageBuildPolicy
      Roles:
        - !Ref 'AutomationDocumentStarterRole'
    Type: AWS::IAM::Policy
  AutomationDocumentStarterRolemainpolicy:
    DependsOn:
      - AutomationDocumentStarterRole
      - ECSImageBuildDocument
      - ECSImageBuildExecutionRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt 'ECSImageBuildExecutionRole.Arn'
          - Action:
              - ssm:StartAutomationExecution
            Effect: Allow
            Resource:
              - !Join
                - ''
                - - 'arn:aws:ssm:'
                  - !Ref 'AWS::Region'
                  - ':'
                  - !Ref 'AWS::AccountId'
                  - :automation-definition/
                  - !Ref 'ECSImageBuildDocument'
                  - :$DEFAULT
      PolicyName: main-policy
      Roles:
        - !Ref 'AutomationDocumentStarterRole'
    Type: AWS::IAM::Policy
  CloudWatchDashboard:
    Properties:
      DashboardBody: !Sub
        - "{\n   \"start\": \"-PT3H\",\n   \"periodOverride\": \"inherit\",\n    \"widgets\": [\n        {\n            \"type\": \"metric\",\n            \"properties\": {\n                \"view\": \"\
          timeSeries\",\n                \"width\": 20,\n                \"height\": 12,\n                \"title\": \"Fargate Resource Utlization\",\n                \"period\": 300,\n                \"\
          stacked\": false,\n                \"metrics\": [\n                    [\n                        \"AWS/ECS\", \n                        \"MemoryUtilization\", \n                        \"ServiceName\"\
          , \n                        \"${PRIMARY_ECS_SERVICE_NAME}\",\n                        \"ClusterName\", \n                        \"${PRIMARY_ECS_CLUSTER_NAME}\",\n                        {\n \
          \                           \"label\": \"PrimaryMemUtilization\"\n                        }\n                    ],\n                    [ \n                        \"AWS/ECS\", \n           \
          \             \"CPUUtilization\", \n                        \"ServiceName\", \n                        \"${PRIMARY_ECS_SERVICE_NAME}\",\n                        \"ClusterName\", \n           \
          \             \"${PRIMARY_ECS_CLUSTER_NAME}\",\n                        {\n                            \"label\": \"PrimaryCPUUtilization\"\n                        }\n                    ],\n\
          \                    [\n                        \"AWS/ECS\", \n                        \"MemoryUtilization\", \n                        \"ServiceName\", \n                        \"${FAILOVER_ECS_SERVICE_NAME}\"\
          ,\n                        \"ClusterName\", \n                        \"${FAILOVER_ECS_CLUSTER_NAME}\",\n                        {\n                            \"label\": \"FailoverMemUtilization\"\
          \n                        }\n                    ],\n                    [ \n                        \"AWS/ECS\", \n                        \"CPUUtilization\", \n                        \"ServiceName\"\
          , \n                        \"${FAILOVER_ECS_SERVICE_NAME}\",\n                        \"ClusterName\", \n                        \"${FAILOVER_ECS_CLUSTER_NAME}\",\n                        {\n\
          \                            \"label\": \"FailoverCPUUtilization\"\n                        }\n                    ]\n                ],\n                \"region\": \"us-east-1\"\n          \
          \  }\n        }\n    ]\n}"
        - FAILOVER_ECS_CLUSTER_NAME: !Ref 'FailoverECSCluster'
          FAILOVER_ECS_SERVICE_NAME: !If
            - IsInitiatorStack
            - !Ref 'FailoverInitiatorECSService'
            - !Ref 'FailoverAcceptorECSService'
          PRIMARY_ECS_CLUSTER_NAME: !Ref 'PrimaryECSCluster'
          PRIMARY_ECS_SERVICE_NAME: !If
            - IsInitiatorStack
            - !Ref 'PrimaryInitiatorECSService'
            - !Ref 'PrimaryAcceptorECSService'
    Type: AWS::CloudWatch::Dashboard
  ConnectionTypeParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine connection type defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - ConnectionType
      Tier: Standard
      Type: String
      Value: !Ref 'ConnectionType'
    Type: AWS::SSM::Parameter
  DatabaseNameParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine MySQL database name for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - DatabaseName
      Tier: Standard
      Type: String
      Value: !Join
        - ''
        - - quickfix-
          - !Select
            - 2
            - !Split
              - /
              - !Ref 'AWS::StackId'
          - ;
    Type: AWS::SSM::Parameter
  DebugLoggingParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX debug logging setting defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - DebugLogging
      Tier: Standard
      Type: String
      Value: !Ref 'DebugLogging'
    Type: AWS::SSM::Parameter
  ECRRepository:
    DependsOn:
      - StackNameManipulator
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: ECR does not allow capital letters in repository names which is why we must sanitize/lowercase the auto-generated name.
    Properties:
      EncryptionConfiguration: !If
        - KMSKeySupplied
        - EncryptionType: KMS
          KmsKey: !Ref 'KMSKeyARN'
        - EncryptionType: AES256
      ImageScanningConfiguration:
        ScanOnPush: true
      RepositoryName: !Join
        - ''
        - - fix-engine-on-aws/
          - !GetAtt 'StackNameManipulator.OutputString'
    Type: AWS::ECR::Repository
  ECSImageBuildDocument:
    DependsOn:
      - ECRRepository
      - ECSImageBuildSecurityGroup
      - ECSImageBuildExecutionRole
      - ECSImageBuildInstanceRoleProfile
    Properties:
      Content:
        assumeRole: '{{ExecutionRoleArn}}'
        description: !Join
          - ''
          - - 'Creates the client and server images use by CloudFormation stack '
            - !Ref 'AWS::StackName'
        mainSteps:
          - action: aws:runInstances
            inputs:
              BlockDeviceMappings:
                - DeviceName: /dev/sda1
                  Ebs:
                    Encrypted: true
                    VolumeSize: 8
                    VolumeType: gp2
              IamInstanceProfileName: !Ref 'ECSImageBuildInstanceRoleProfile'
              ImageId: '{{LatestAmazonLinux2AMIId}}'
              InstanceType: t3a.small
              MaxInstanceCount: 1
              MinInstanceCount: 1
              SecurityGroupIds:
                - !Ref 'ECSImageBuildSecurityGroup'
              SubnetId: !Ref 'PrimaryPrivateSubnet'
              TagSpecifications:
                - ResourceType: instance
                  Tags:
                    - Key: Name
                      Value: !Join
                        - '-'
                        - - !Ref 'AWS::StackName'
                          - ECSImageBuilder
                    - Key: LaunchedBy
                      Value: SSMAutomation
                    - Key: StackName
                      Value: !Ref 'AWS::StackName'
            maxAttempts: 3
            name: LaunchInstance
            onFailure: step:SignalFailure
            timeoutSeconds: 300
          - action: aws:runCommand
            inputs:
              CloudWatchOutputConfig:
                CloudWatchLogGroupName: !Ref 'ECSImageBuildLogGroup'
                CloudWatchOutputEnabled: true
              DocumentName: AWS-RunShellScript
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Parameters:
                commands:
                  - sudo yum update -y
                  - sudo yum install jq git docker java-11-amazon-corretto-devel -y
                  - '# Installs Gradle'
                  - sudo wget -c https://services.gradle.org/distributions/gradle-6.9.4-all.zip
                  - sudo unzip gradle-6.9.4-all.zip -d /opt
                  - sudo ln -s /opt/gradle-6.9.4 /opt/gradle
                  - export GRADLE_HOME=/opt/gradle
                  - export PATH=$PATH:\/opt/gradle/bin
                  - cd /tmp
                  - !Join
                    - ''
                    - - 'git clone '
                      - !Ref 'GitHubRepoUrl'
                  - cd amazon-resilient-fix-engine-demo
                  - !Join
                    - ''
                    - - 'git checkout '
                      - !Ref 'GitHubRepoBranch'
                  - !Join
                    - ' '
                    - - sh scripts/dockerbuild.sh --region
                      - !Ref 'AWS::Region'
                      - --account-id
                      - !Ref 'AWS::AccountId'
                      - --ecr-repo-name
                      - !Ref 'ECRRepository'
                      - --engine-role
                      - !If
                        - IsAcceptorStack
                        - Server
                        - Client
            name: BuildECSImage
            onFailure: step:TerminateInstanceOnFailure
            timeoutSeconds: 1800
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: ECSImageBuildWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: SUCCESS
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnFailure
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: ECSImageBuildWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: FAILURE
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalFailure
        parameters:
          ExecutionRoleArn:
            default: !GetAtt 'ECSImageBuildExecutionRole.Arn'
            description: The service role to use for this automation.
            type: String
          LatestAmazonLinux2AMIId:
            default: '{{ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs}}'
            description: The latest Amazon Linux 2 AMI queried from the public parameter.
            type: String
        schemaVersion: '0.3'
      DocumentType: Automation
    Type: AWS::SSM::Document
  ECSImageBuildExecutionRole:
    DependsOn:
      - ECSImageBuildInstanceRole
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ::image/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :subnet/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :security-group/
                      - !GetAtt 'ECSImageBuildSecurityGroup.GroupId'
              - Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !GetAtt 'ECSImageBuildInstanceRole.Arn'
              - Action:
                  - cloudformation:SignalResource
                Effect: Allow
                Resource:
                  - !Ref 'AWS::StackId'
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  ECSImageBuildInstanceRole:
    DependsOn:
      - ECRRepository
      - ECSImageBuildLogGroup
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: ecr:GetAuthorizationToken does not support resource filtering.
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ecr:PutImage
                  - ecr:UploadLayerPart
                  - ecr:InitiateLayerUpload
                  - ecr:CompleteLayerUpload
                  - ecr:BatchCheckLayerAvailability
                Effect: Allow
                Resource:
                  - !GetAtt 'ECRRepository.Arn'
              - Action:
                  - ecr:GetAuthorizationToken
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'ECSImageBuildLogGroup'
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'ECSImageBuildLogGroup'
                      - :log-stream:*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  ECSImageBuildInstanceRoleProfile:
    DependsOn:
      - ECSImageBuildInstanceRole
    Properties:
      Path: /
      Roles:
        - !Ref 'ECSImageBuildInstanceRole'
    Type: AWS::IAM::InstanceProfile
  ECSImageBuildLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: These logs do not contain sensitive data.
    Properties:
      LogGroupName: !Join
        - /
        - - /aws/ssm
          - !Ref 'AWS::StackName'
          - ECSImageBuild
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  ECSImageBuildSecurityGroup:
    DependsOn: []
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: Outbound HTTP(S) traffic is required to download third-party dependencies.
    Properties:
      GroupDescription: Security Group for EC2 Instances Launched via SSM Automation
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: All HTTP Traffic
          FromPort: 80
          IpProtocol: tcp
          ToPort: 80
        - CidrIp: '0.0.0.0/0'
          Description: Allow All HTTPS Traffic
          FromPort: 443
          IpProtocol: tcp
          ToPort: 443
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  ECSImageBuildStarter:
    DependsOn:
      - ECRRepository
      - AutomationDocumentStarterRoleECSImageBuildPolicy
      - ECSImageBuildDocument
      - AutomationDocumentStarterLogGroup
    Properties:
      Properties:
        AutomationDocumentName: !Ref 'ECSImageBuildDocument'
        EligibleRequestTypes:
          - Create
          - Update
        ExecutionRoleArn: !GetAtt 'ECSImageBuildExecutionRole.Arn'
        RepositoryName: !Ref 'ECRRepository'
        TemplateVersion: '1'
      ServiceToken: !GetAtt 'AutomationDocumentStarter.Arn'
      Type: Custom::StartSSMAutomationDocument
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  ECSImageBuildWaiter:
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT20M
    DependsOn:
      - AutomationDocumentStarterRoleECSImageBuildPolicy
      - ECSImageBuildDocument
      - AutomationDocumentStarterLogGroup
    Type: AWS::CloudFormation::WaitCondition
  ECSImageRemover:
    DependsOn:
      - ECSImageRemoverRole
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\nfrom botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - RepositoryName | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\
          \n    responseData = {}\n\n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n    properties = event['ResourceProperties']['Properties']\n    \n    if event['RequestType']\
          \ in ['Delete']:\n        \n        ecr_client = boto3.client('ecr')\n\n        try:\n            \n            existing_images = ecr_client.describe_images(\n                repositoryName =\
          \ properties['RepositoryName']\n            )\n            \n            if len(existing_images['imageDetails']) > 0:\n                \n                images_to_delete = []\n               \
          \ for image in existing_images['imageDetails']:\n                    \n                    images_to_delete.append({\n                        'imageDigest': image['imageDigest']\n            \
          \        })\n                    \n                ecr_client.batch_delete_image(\n                    repositoryName = properties['RepositoryName'],\n                    imageIds = images_to_delete\n\
          \                )\n                \n            return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, properties['RepositoryName'])\n            \n        except ClientError\
          \ as e:\n        \n            print(str(e))\n            return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n    \n    elif event['RequestType'] in ['Create', 'Update']:\n\
          \        \n        return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)"
      Description: ''
      Handler: index.handler
      Layers: []
      MemorySize: 128
      Role: !GetAtt 'ECSImageRemoverRole.Arn'
      Runtime: python3.9
      Timeout: 60
      TracingConfig:
        Mode: PassThrough
    Type: AWS::Lambda::Function
  ECSImageRemoverLogGroup:
    DeletionPolicy: Delete
    DependsOn:
      - ECSImageRemover
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'ECSImageRemover'
      RetentionInDays: 30
    Type: AWS::Logs::LogGroup
  ECSImageRemoverResource:
    DependsOn:
      - ECRRepository
      - ECSImageRemover
      - ECSImageRemoverLogGroup
    Properties:
      Properties:
        RepositoryName: !Ref 'ECRRepository'
      ServiceToken: !GetAtt 'ECSImageRemover.Arn'
      Type: Custom::ECSImageRemover
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  ECSImageRemoverRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      MaxSessionDuration: 3600
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ecr:DescribeImages
                  - ecr:BatchDeleteImage
                Effect: Allow
                Resource:
                  - !GetAtt 'ECRRepository.Arn'
          PolicyName: main-policy
    Type: AWS::IAM::Role
  FIXClientPrefixListUpdater:
    DependsOn:
      - FIXClientVPCPrefixList
      - VPCPrefixListManagerLogGroup
    Properties:
      Properties:
        AuthorizedCidrs: !Ref 'FIXClientCIDRs'
        EntryDescription: !Join
          - ''
          - - 'Authorized FIX Client CIDR in '
            - !Ref 'AWS::StackName'
            - ' stack'
        PrefixListId: !Ref 'FIXClientVPCPrefixList'
      ServiceToken: !GetAtt 'VPCPrefixListManager.Arn'
      Type: Custom::UpdateFIXClientPrefixList
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  FIXClientVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      MaxEntries: 5
      PrefixListName: !Join
        - ''
        - - !Ref 'AWS::StackName'
          - '-'
          - FIXClientCIDRs
    Type: AWS::EC2::PrefixList
  FIXServerDNSNameParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Socket connection host for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXServerDNSName
      Tier: Standard
      Type: String
      Value: !If
        - FIXServerDNSNameSupplied
        - !Ref 'FIXServerDNSName'
        - None
    Type: AWS::SSM::Parameter
  FIXServerPortParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine server port defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXServerPort
      Tier: Standard
      Type: String
      Value: !Ref 'FIXServerPort'
    Type: AWS::SSM::Parameter
  FIXVersionIntParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine version as integer for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXVersionInt
      Tier: Standard
      Type: String
      Value: !Join
        - ''
        - !Split
          - .
          - !Ref 'FIXVersion'
    Type: AWS::SSM::Parameter
  FIXVersionParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine version for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXVersion
      Tier: Standard
      Type: String
      Value: !Ref 'FIXVersion'
    Type: AWS::SSM::Parameter
  FailoverAcceptorECSService:
    Condition: IsAcceptorStack
    DependsOn:
      - FailoverECSCluster
      - FargateSecurityGroup
      - FailoverAcceptorECSTaskDefinition
      - FailoverTargetGroup
      - FailoverNLBListener
    Properties:
      Cluster: !Ref 'FailoverECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Ref 'AWS::StackName'
          ContainerPort: !Ref 'FIXServerPort'
          TargetGroupArn: !Ref 'FailoverTargetGroup'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'FailoverPrivateSubnet'
      TaskDefinition: !Ref 'FailoverAcceptorECSTaskDefinition'
    Type: AWS::ECS::Service
  FailoverAcceptorECSTaskDefinition:
    Condition: IsAcceptorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - ECSImageBuildWaiter
      - FargateExecutionRole
      - GlobalAccelerator
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
            - Name: GLOBAL_ACCELERATOR_ARN
              Value: !If
                - IsAcceptorStack
                - !GetAtt 'GlobalAccelerator.AcceleratorArn'
                - ''
            - Name: GLOBAL_ACCELERATOR_ENDPOINT_ARN
              Value: !If
                - IsAcceptorStack
                - !Ref 'FailoverNLB'
                - ''
          Essential: true
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Failover
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  FailoverECSCluster:
    Type: AWS::ECS::Cluster
  FailoverInitiatorECSService:
    Condition: IsInitiatorStack
    DependsOn:
      - FailoverECSCluster
      - FargateSecurityGroup
      - FailoverInitiatorECSTaskDefinition
    Properties:
      Cluster: !Ref 'FailoverECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'FailoverPrivateSubnet'
      TaskDefinition: !Ref 'FailoverInitiatorECSTaskDefinition'
    Type: AWS::ECS::Service
  FailoverInitiatorECSTaskDefinition:
    Condition: IsInitiatorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - ECSImageBuildWaiter
      - FargateExecutionRole
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
          Essential: true
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Failover
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  FailoverNLB:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      IpAddressType: ipv4
      LoadBalancerAttributes: !If
        - SendLogsToS3
        - - Key: access_logs.s3.enabled
            Value: 'true'
          - Key: access_logs.s3.bucket
            Value: !Ref 'S3LogsBucket'
          - Key: access_logs.s3.prefix
            Value: ''
        - - Key: access_logs.s3.enabled
            Value: 'false'
      Scheme: internet-facing
      Subnets:
        - !Ref 'FailoverPublicSubnet'
      Type: network
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  FailoverNLBListener:
    Condition: IsAcceptorStack
    DependsOn:
      - FailoverNLB
      - FailoverTargetGroup
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'FailoverTargetGroup'
          Type: forward
      LoadBalancerArn: !Ref 'FailoverNLB'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::ElasticLoadBalancingV2::Listener
  FailoverTargetGroup:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      HealthCheckEnabled: true
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
      TargetGroupAttributes:
        - Key: stickiness.type
          Value: source_ip
        - Key: stickiness.enabled
          Value: 'false'
      TargetType: ip
      VpcId: !Ref 'VPC'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  FargateExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
    Type: AWS::IAM::Role
  FargateLogGroup:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: These logs do not contain sensitive data.
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/ecs/fargate/
          - !Ref 'AWS::StackName'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  FargateSecurityGroup:
    DependsOn:
      - Route53HealthCheckVPCPrefixList
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: Outbound HTTP(S) traffic is required to download third-party dependencies.
    Properties:
      GroupDescription: Security Group for Fargate Tasks
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: All HTTP Traffic
          FromPort: 80
          IpProtocol: tcp
          ToPort: 80
        - CidrIp: '0.0.0.0/0'
          Description: All HTTPS Traffic
          FromPort: 443
          IpProtocol: tcp
          ToPort: 443
        - CidrIp: '0.0.0.0/0'
          Description: FIX Server Traffic
          FromPort: !Ref 'FIXServerPort'
          IpProtocol: tcp
          ToPort: !Ref 'FIXServerPort'
      SecurityGroupIngress:
        - Description: FIX Engine Access for FIX Clients
          FromPort: !If
            - IsAcceptorStack
            - !Ref 'FIXServerPort'
            - 32768
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'FIXClientVPCPrefixList'
          ToPort: !If
            - IsAcceptorStack
            - !Ref 'FIXServerPort'
            - 65535
        - Description: AWS Route53 Health Checks
          FromPort: !Ref 'FIXServerPort'
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'Route53HealthCheckVPCPrefixList'
          ToPort: !Ref 'FIXServerPort'
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  FargateTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ssm:GetParameter
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ssm:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :parameter/fixengine/
                      - !Ref 'AWS::StackName'
                      - /*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  FargateTaskRoleGAPolicy:
    Condition: IsAcceptorStack
    DependsOn:
      - FargateTaskRole
      - GlobalAcceleratorEndpointGroup
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - globalaccelerator:UpdateEndpointGroup
              - globalaccelerator:DescribeEndpointGroup
            Effect: Allow
            Resource:
              - !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
      PolicyName: global-accelerator-access
      Roles:
        - !Ref 'FargateTaskRole'
    Type: AWS::IAM::Policy
  GlobalAccelerator:
    Condition: IsAcceptorStack
    Properties:
      Enabled: true
      Name: !Ref 'AWS::StackName'
    Type: AWS::GlobalAccelerator::Accelerator
  GlobalAcceleratorArnParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator ARN for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorArn
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAccelerator.AcceleratorArn'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorDNSNameParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator DNS name for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorDNSName
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAccelerator.DnsName'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorDNSRecord:
    Condition: CreateEndpointRecord
    DependsOn:
      - GlobalAccelerator
    Properties:
      HostedZoneId: !Ref 'HostedZoneID'
      RecordSets:
        - AliasTarget:
            DNSName: !GetAtt 'GlobalAccelerator.DnsName'
            HostedZoneId: Z2BJ6XQ5FK7U4H
          Name: !Ref 'FIXServerDNSName'
          Type: A
    Type: AWS::Route53::RecordSetGroup
  GlobalAcceleratorEndpointGroup:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryNLB
      - FailoverNLB
      - GlobalAcceleratorListener
    Properties:
      EndpointConfigurations:
        - EndpointId: !Ref 'PrimaryNLB'
          Weight: 100
        - EndpointId: !Ref 'FailoverNLB'
          Weight: 0
      EndpointGroupRegion: !Ref 'AWS::Region'
      ListenerArn: !Ref 'GlobalAcceleratorListener'
    Type: AWS::GlobalAccelerator::EndpointGroup
  GlobalAcceleratorEndpointGroupArnParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator Group Endpoint ARN for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorEndpointGroupArn
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorIPAddressesParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator IP addresses for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorIPAddresses
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAcceleratorInfoRetrieverResource.IPAddresses'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorInfoRetriever:
    DependsOn:
      - GlobalAcceleratorInfoRetrieverRole
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: "import json\nimport time\nimport boto3\nimport logging\nimport cfnresponse\nfrom botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\n\
          logging.getLogger('boto3').setLevel(logging.INFO)\nlogging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - AcceleratorArn | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('-----\
          \ REQUEST RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData = {}\n    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n    properties = event['ResourceProperties']['Properties']\n\
          \    \n    if event['RequestType'] in ['Create', 'Update']:\n        \n        time.sleep(60)\n\n        accelerator_client = boto3.client('globalaccelerator', region_name = 'us-west-2')\n\n \
          \       try:\n\n            response = accelerator_client.describe_accelerator(\n                AcceleratorArn = properties['AcceleratorArn']\n            )\n\n            if 'Accelerator' not\
          \ in response:\n\n                return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n\n            else:\n\n                responseData['IPAddresses'] = ','.join(response['Accelerator']['IpSets'][0]['IpAddresses'])\n\
          \                return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, properties['AcceleratorArn'])\n\n        except ClientError as e:\n            print(str(e))\n     \
          \       return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n            \n    elif event['RequestType'] in ['Delete']:\n        \n        return cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, responseData)"
      Description: ''
      Handler: index.handler
      Layers: []
      MemorySize: 128
      Role: !GetAtt 'GlobalAcceleratorInfoRetrieverRole.Arn'
      Runtime: python3.9
      Timeout: 90
      TracingConfig:
        Mode: PassThrough
    Type: AWS::Lambda::Function
  GlobalAcceleratorInfoRetrieverLogGroup:
    DeletionPolicy: Delete
    DependsOn:
      - GlobalAcceleratorInfoRetriever
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'GlobalAcceleratorInfoRetriever'
      RetentionInDays: 30
    Type: AWS::Logs::LogGroup
  GlobalAcceleratorInfoRetrieverResource:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAccelerator
      - GlobalAcceleratorInfoRetriever
      - GlobalAcceleratorInfoRetrieverLogGroup
    Properties:
      Properties:
        AcceleratorArn: !Ref 'GlobalAccelerator'
      ServiceToken: !GetAtt 'GlobalAcceleratorInfoRetriever.Arn'
      Type: Custom::GetAcceleratorInfo
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  GlobalAcceleratorInfoRetrieverRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      MaxSessionDuration: 3600
      Policies: []
    Type: AWS::IAM::Role
  GlobalAcceleratorInfoRetrieverRolemainpolicy:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAcceleratorInfoRetrieverRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - globalaccelerator:DescribeAccelerator
            Effect: Allow
            Resource:
              - !GetAtt 'GlobalAccelerator.AcceleratorArn'
      PolicyName: main-policy
      Roles:
        - !Ref 'GlobalAcceleratorInfoRetrieverRole'
    Type: AWS::IAM::Policy
  GlobalAcceleratorListener:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAccelerator
    Properties:
      AcceleratorArn: !Ref 'GlobalAccelerator'
      ClientAffinity: NONE
      PortRanges:
        - FromPort: !Ref 'FIXServerPort'
          ToPort: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::GlobalAccelerator::Listener
  MemoryDBHostParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine MemoryDB host for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - MemoryDBHost
      Tier: Standard
      Type: String
      Value: !GetAtt 'MemoryDbCluster.ClusterEndpoint.Address'
    Type: AWS::SSM::Parameter
  MemoryDBPortParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine MemoryDB port for the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - MemoryDBPort
      Tier: Standard
      Type: String
      Value: '6379'
    Type: AWS::SSM::Parameter
  MemoryDBSecurityGroup:
    DependsOn:
      - FargateSecurityGroup
    Properties:
      GroupDescription: Security Group for Memory DB Cluster
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/32'
          Description: Deny All Outgoing Traffic
          FromPort: 1
          IpProtocol: tcp
          ToPort: 1
      SecurityGroupIngress:
        - Description: Access from Private User App Ranges
          FromPort: 6379
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'UserApplicationVPCPrefixList'
          ToPort: 6379
        - Description: Access from Farget Cluster
          FromPort: 6379
          IpProtocol: tcp
          SourceSecurityGroupId: !Ref 'FargateSecurityGroup'
          ToPort: 6379
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  MemoryDbAcl:
    Properties:
      ACLName: !Ref 'AWS::StackName'
    Type: AWS::MemoryDB::ACL
  MemoryDbCluster:
    DependsOn:
      - MemoryDbAcl
      - MemoryDbSubnetGroup
    Properties:
      ACLName: !Ref 'AWS::StackName'
      AutoMinorVersionUpgrade: false
      ClusterName: !Ref 'AWS::StackName'
      NodeType: db.r6g.large
      NumReplicasPerShard: 1
      NumShards: 1
      SecurityGroupIds:
        - !Ref 'MemoryDBSecurityGroup'
      SubnetGroupName: !Ref 'AWS::StackName'
      TLSEnabled: true
    Type: AWS::MemoryDB::Cluster
  MemoryDbSubnetGroup:
    Properties:
      SubnetGroupName: !Ref 'AWS::StackName'
      SubnetIds:
        - !Ref 'PrimaryPrivateSubnet'
        - !Ref 'FailoverPrivateSubnet'
    Type: AWS::MemoryDB::SubnetGroup
  MiscMethodsHandler:
    DependsOn:
      - MiscMethodsHandlerRole
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: "import json\nimport logging\nimport cfnresponse\nfrom botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\n\ndef handler(event, context):\n\
          \n    LOGGER.info('----- REQUEST RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    response_data = {}\n    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if event['RequestType'] in ['Create', 'Update']:\n        \n        if operation == 'ManipulateString':\n            \n \
          \           action = properties['Action']\n            input_str = properties['InputString']\n            \n            if action == 'lower':\n                sanitized_str = input_str.lower()\n\
          \                \n            elif action == 'upper':\n                sanitized_str = input_str.upper()\n                \n            response_data['OutputString'] = sanitized_str\n       \
          \     return cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data, sanitized_str)\n                \n    elif event['RequestType'] in ['Delete']:\n        \n        return cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, response_data)"
      Description: ''
      Handler: index.handler
      Layers: []
      MemorySize: 128
      Role: !GetAtt 'MiscMethodsHandlerRole.Arn'
      Runtime: python3.9
      Timeout: 60
      TracingConfig:
        Mode: PassThrough
    Type: AWS::Lambda::Function
  MiscMethodsHandlerLogGroup:
    DeletionPolicy: Delete
    DependsOn:
      - MiscMethodsHandler
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'MiscMethodsHandler'
      RetentionInDays: 30
    Type: AWS::Logs::LogGroup
  MiscMethodsHandlerRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      MaxSessionDuration: 3600
      Policies: []
    Type: AWS::IAM::Role
  PrimaryAcceptorECSService:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryECSCluster
      - FargateSecurityGroup
      - PrimaryAcceptorECSTaskDefinition
      - PrimaryTargetGroup
      - PrimaryNLBListener
    Properties:
      Cluster: !Ref 'PrimaryECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Ref 'AWS::StackName'
          ContainerPort: !Ref 'FIXServerPort'
          TargetGroupArn: !Ref 'PrimaryTargetGroup'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'PrimaryPrivateSubnet'
      TaskDefinition: !Ref 'PrimaryAcceptorECSTaskDefinition'
    Type: AWS::ECS::Service
  PrimaryAcceptorECSTaskDefinition:
    Condition: IsAcceptorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - ECSImageBuildWaiter
      - FargateExecutionRole
      - GlobalAccelerator
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
            - Name: GLOBAL_ACCELERATOR_ARN
              Value: !If
                - IsAcceptorStack
                - !GetAtt 'GlobalAccelerator.AcceleratorArn'
                - ''
            - Name: GLOBAL_ACCELERATOR_ENDPOINT_ARN
              Value: !If
                - IsAcceptorStack
                - !Ref 'PrimaryNLB'
                - ''
          Essential: true
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Primary
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  PrimaryECSCluster:
    Type: AWS::ECS::Cluster
  PrimaryInitiatorECSService:
    Condition: IsInitiatorStack
    DependsOn:
      - PrimaryECSCluster
      - FargateSecurityGroup
      - PrimaryInitiatorECSTaskDefinition
    Properties:
      Cluster: !Ref 'PrimaryECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'PrimaryPrivateSubnet'
      TaskDefinition: !Ref 'PrimaryInitiatorECSTaskDefinition'
    Type: AWS::ECS::Service
  PrimaryInitiatorECSTaskDefinition:
    Condition: IsInitiatorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - ECSImageBuildWaiter
      - FargateExecutionRole
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
          Essential: true
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Primary
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  PrimaryNLB:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      IpAddressType: ipv4
      LoadBalancerAttributes: !If
        - SendLogsToS3
        - - Key: access_logs.s3.enabled
            Value: 'true'
          - Key: access_logs.s3.bucket
            Value: !Ref 'S3LogsBucket'
          - Key: access_logs.s3.prefix
            Value: ''
        - - Key: access_logs.s3.enabled
            Value: 'false'
      Scheme: internet-facing
      Subnets:
        - !Ref 'PrimaryPublicSubnet'
      Type: network
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  PrimaryNLBListener:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryNLB
      - PrimaryTargetGroup
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'PrimaryTargetGroup'
          Type: forward
      LoadBalancerArn: !Ref 'PrimaryNLB'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::ElasticLoadBalancingV2::Listener
  PrimaryTargetGroup:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      HealthCheckEnabled: true
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
      TargetGroupAttributes:
        - Key: stickiness.type
          Value: source_ip
        - Key: stickiness.enabled
          Value: 'false'
      TargetType: ip
      VpcId: !Ref 'VPC'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  Route53HealthCheckVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      Entries:
        - Cidr: 15.177.0.0/18
          Description: AWS:ROUTE53_HEALTHCHECKS:GLOBAL
        - Cidr: 52.80.197.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.80.197.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.80.198.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.83.34.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 52.83.35.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 52.83.35.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 54.248.220.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-northeast-1
        - Cidr: 54.250.253.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-northeast-1
        - Cidr: 54.251.31.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-1
        - Cidr: 54.255.254.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-1
        - Cidr: 54.252.254.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-2
        - Cidr: 54.252.79.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-2
        - Cidr: 176.34.159.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:eu-west-1
        - Cidr: 54.228.16.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:eu-west-1
        - Cidr: 177.71.207.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:sa-east-1
        - Cidr: 54.232.40.64/26
          Description: AWS:ROUTE53_HEALTHCHECKS:sa-east-1
        - Cidr: 107.23.255.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-east-1
        - Cidr: 54.243.31.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-east-1
        - Cidr: 54.183.255.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-1
        - Cidr: 54.241.32.64/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-1
        - Cidr: 54.244.52.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-2
        - Cidr: 54.245.168.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-2
      MaxEntries: 30
      PrefixListName: AWS:Route53HealthChecks
    Type: AWS::EC2::PrefixList
  SenderCompIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine sender computer ID defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - SenderCompID
      Tier: Standard
      Type: String
      Value: !Ref 'SenderCompID'
    Type: AWS::SSM::Parameter
  StackNameManipulator:
    DependsOn:
      - MiscMethodsHandlerLogGroup
    Properties:
      Properties:
        Action: lower
        InputString: !Ref 'AWS::StackName'
      ServiceToken: !GetAtt 'MiscMethodsHandler.Arn'
      Type: Custom::ManipulateString
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  TargetCompIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine target computer ID defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - TargetCompID
      Tier: Standard
      Type: String
      Value: !Ref 'TargetCompID'
    Type: AWS::SSM::Parameter
  UserApplicationPrefixListUpdater:
    DependsOn:
      - UserApplicationVPCPrefixList
      - VPCPrefixListManagerLogGroup
    Properties:
      Properties:
        AuthorizedCidrs: !Ref 'UserApplicationCIDRs'
        EntryDescription: !Join
          - ''
          - - 'Authorized User Application CIDR in '
            - !Ref 'AWS::StackName'
            - ' stack'
        PrefixListId: !Ref 'UserApplicationVPCPrefixList'
      ServiceToken: !GetAtt 'VPCPrefixListManager.Arn'
      Type: Custom::UpdateUserApplicationPrefixList
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  UserApplicationVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      MaxEntries: 5
      PrefixListName: !Join
        - ''
        - - !Ref 'AWS::StackName'
          - '-'
          - UserAppCIDRs
    Type: AWS::EC2::PrefixList
  VPCPrefixListManager:
    DependsOn:
      - VPCPrefixListManagerRole
    Properties:
      Architectures:
        - x86_64
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\nfrom botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - PrefixListId | str\n    - AuthorizedCidrs | list\n    - EntryDescription | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('-----\
          \ REQUEST RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData = {}\n    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n    properties = event['ResourceProperties']['Properties']\n\
          \    \n    # If the Stack is Being Created or Updated\n    if event['RequestType'] in ['Create', 'Update']:\n        \n        ec2_client = boto3.client('ec2')\n        \n        try:\n      \
          \      \n            prefix_list = ec2_client.describe_managed_prefix_lists(\n                PrefixListIds = [\n                    properties['PrefixListId']\n                ]\n           \
          \ )\n            \n            if len(prefix_list['PrefixLists']) == 0:\n                print('Prefix List w/ ID: ' + properties['PrefixListId'] + ' Could Not be Found')\n                return\
          \ cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n                \n            else:\n                prefix_list = prefix_list['PrefixLists'][0]\n                \n     \
          \       existing_entries = ec2_client.get_managed_prefix_list_entries(\n                PrefixListId = prefix_list['PrefixListId'],\n            )\n        \n        except ClientError as e:\n\
          \            print(str(e))\n            return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n            \n        new_entries = properties['AuthorizedCidrs']\n        \n\
          \        entries_to_add = []\n        entries_to_remove = []\n        \n        # If There Are Existing Entries\n        if len(existing_entries['Entries']) > 0:\n            \n            # For\
          \ Each Existing Entry\n            for existing_entry in existing_entries['Entries']:\n                \n                # If the CIDR is No Longer Authorized\n                if existing_entry['Cidr']\
          \ not in new_entries:\n                    \n                    # We'll Queue it for Removal\n                    entries_to_remove.append({\n                        'Cidr': existing_entry['Cidr']\n\
          \                    })\n                \n                # Else, We'll Remove it from our \"New Entries\" List\n                else:\n                    new_entries.remove(existing_entry['Cidr'])\n\
          \        \n        # For Each New Entry Remaining\n        for new_entry in new_entries:\n            \n            # We'll Format its Input\n            entries_to_add.append({\n            \
          \    'Cidr': new_entry,\n                'Description': properties['EntryDescription'],\n            })\n        \n        # If There's at Least 1 Entry to Add or Remove\n        if len(entries_to_add)\
          \ > 0 or len(entries_to_remove) > 0:\n            \n            try:\n                \n                # We'll Try to Update the List\n                ec2_client.modify_managed_prefix_list(\n\
          \                    PrefixListId = prefix_list['PrefixListId'],\n                    CurrentVersion = prefix_list['Version'],\n                    AddEntries = entries_to_add,\n             \
          \       RemoveEntries = entries_to_remove,\n                )\n                \n            except ClientError as e:\n                print(str(e))\n                return cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, responseData)\n        \n        return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, properties['PrefixListId'])\n    \n    # If the Stack\
          \ is Being Deleted   \n    elif event['RequestType'] in ['Delete']:\n        \n        # CFN Can Delete Prefix Lists Containing Entries, So There's Nothing For Us to Do\n        return cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, responseData)"
      Description: ''
      Handler: index.handler
      Layers: []
      MemorySize: 128
      Role: !GetAtt 'VPCPrefixListManagerRole.Arn'
      Runtime: python3.9
      Timeout: 60
      TracingConfig:
        Mode: PassThrough
    Type: AWS::Lambda::Function
  VPCPrefixListManagerLogGroup:
    DeletionPolicy: Delete
    DependsOn:
      - VPCPrefixListManager
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'VPCPrefixListManager'
      RetentionInDays: 30
    Type: AWS::Logs::LogGroup
  VPCPrefixListManagerRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      MaxSessionDuration: 3600
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:DescribeManagedPrefixLists
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - ec2:ModifyManagedPrefixList
                  - ec2:GetManagedPrefixListEntries
                Effect: Allow
                Resource:
                  - !GetAtt 'FIXClientVPCPrefixList.Arn'
                  - !GetAtt 'UserApplicationVPCPrefixList.Arn'
          PolicyName: main-policy
    Type: AWS::IAM::Role
