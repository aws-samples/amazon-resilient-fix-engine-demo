Conditions:
  CreateAlarms: !Not
    - !Equals
      - ''
      - !Ref 'SNSTopicArn'
  CreateEndpointRecord: !And
    - !Condition 'IsAcceptorStack'
    - !Condition 'HostedZoneSupplied'
    - !Condition 'FIXServerDNSNameSupplied'
  FIXServerDNSNameSupplied: !Not
    - !Equals
      - ''
      - !Ref 'FIXServerDNSName'
  HostedZoneSupplied: !Not
    - !Equals
      - ''
      - !Ref 'HostedZoneID'
  IsAcceptorStack: !Equals
    - acceptor
    - !Ref 'ConnectionType'
  IsInitiatorStack: !Equals
    - initiator
    - !Ref 'ConnectionType'
  KafkaTLSEnabled: !Equals
    - 'true'
    - !Ref 'KafkaConnTLS'
  SendLogsToS3: !Not
    - !Equals
      - ''
      - !Ref 'S3LogsBucket'
  UseDefaultImage: !Equals
    - ''
    - !Ref 'CustomImagePath'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: FIX Configuration
        Parameters:
          - FIXVersion
          - FIXServerPort
          - ConnectionType
          - DebugLogging
          - TargetCompID
          - SenderCompID
          - KafkaConnTLS
          - ApplicationID
          - CustomImagePath
      - Label:
          default: Networking
        Parameters:
          - VPC
          - PrimaryPublicSubnet
          - FailoverPublicSubnet
          - PrimaryPrivateSubnet
          - FailoverPrivateSubnet
      - Label:
          default: Security
        Parameters:
          - FIXClientCIDRs
          - UserApplicationCIDRs
      - Label:
          default: Accessibility
        Parameters:
          - HostedZoneID
          - FIXServerDNSName
      - Label:
          default: Logging, Monitoring & Alerting
        Parameters:
          - S3LogsBucket
          - S3LogsBucketPrefix
          - SNSTopicArn
          - LogRetentionInDays
    ParameterLabels:
      CustomImagePath:
        default: Image Path
      FIXClientCIDRs:
        default: FIX Client CIDRs
      FIXServerDNSName:
        default: FIX Server DNS Name
      FIXVersion:
        default: FIX Version
      FailoverPrivateSubnet:
        default: Failover Private Subnet
      FailoverPrivateSubnetCIDR:
        default: Failover Private Subnet CIDR
      FailoverPublicSubnet:
        default: Failover Public Subnet
      FailoverPublicSubnetCIDR:
        default: Failover Public Subnet CIDR
      HostedZoneID:
        default: Hosted Zone
      LogRetentionInDays:
        default: Log Retention in Days
      PrimaryPrivateSubnet:
        default: Primary Private Subnet
      PrimaryPrivateSubnetCIDR:
        default: Primary Private Subnet CIDR
      PrimaryPublicSubnet:
        default: Primary Public Subnet
      PrimaryPublicSubnetCIDR:
        default: Primary Public Subnet CIDR
      S3LogsBucket:
        default: Logs Bucket
      S3LogsBucketPrefix:
        default: Logs Bucket Prefix
      SNSTopicArn:
        default: Target SNS Topic
      UserApplicationCIDRs:
        default: User Application CIDRs
      VPC:
        default: VPC
      VpcCIDR:
        default: VPC CIDR
  Comments: FIX Engine on AWS POC
  CreatedBy: Carter Meyers
  Description: FIXEngineOnAWS - v1.34
  LastUpdated: July 13, 2021
  Version: v1.34
Outputs:
  ApplicationID:
    Condition: ''
    Value: !Ref 'ApplicationID'
  ConnectionType:
    Condition: ''
    Value: !Ref 'ConnectionType'
  DebugLogging:
    Condition: ''
    Value: !Ref 'DebugLogging'
  FIXServerDNSName:
    Condition: ''
    Value: !If
      - FIXServerDNSNameSupplied
      - !Ref 'FIXServerDNSName'
      - None
  FIXServerPort:
    Condition: ''
    Value: !Ref 'FIXServerPort'
  FIXVersion:
    Condition: ''
    Value: !Ref 'FIXVersion'
  FIXVersionInt:
    Condition: ''
    Value: !Join
      - ''
      - !Split
        - .
        - !Ref 'FIXVersion'
  FailoverMSKEndpoint:
    Condition: ''
    Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
  GlobalAcceleratorArn:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAccelerator.AcceleratorArn'
  GlobalAcceleratorDNSName:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAccelerator.DnsName'
  GlobalAcceleratorEndpointGroupArn:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
  GlobalAcceleratorIPAddresses:
    Condition: IsAcceptorStack
    Value: !GetAtt 'GlobalAcceleratorInfoRetriever.IPAddresses'
  KafkaConnTLS:
    Condition: ''
    Value: !Ref 'KafkaConnTLS'
  KafkaPort:
    Condition: ''
    Value: !If
      - KafkaTLSEnabled
      - '9094'
      - '9092'
  PrimaryMSKEndpoint:
    Condition: ''
    Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
  RDSClusterNonAdminSecretArn:
    Condition: ''
    Value: !Ref 'RDSClusterNonAdminSecret'
  RDSClusterSecretArn:
    Condition: ''
    Value: !Ref 'RDSClusterAdminSecret'
  SenderCompID:
    Condition: ''
    Value: !Ref 'SenderCompID'
  TargetCompID:
    Condition: ''
    Value: !Ref 'TargetCompID'
Parameters:
  ApplicationID:
    Default: server
    Description: ''
    Type: String
  ConnectionType:
    AllowedValues:
      - acceptor
      - initiator
    Default: acceptor
    Description: The engine role to be deployed - acceptor for server, initiator for
      client
    Type: String
  CustomImagePath:
    Default: ''
    Description: "[Optional] This CloudFormation stack will create a Docker image\
      \ to be used by ECS. If you wish to use your own image, specify the path here.\
      \ \n        Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores,\
      \ colons, periods, forward slashes, and number signs are allowed."
    Type: String
  DebugLogging:
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'
    Description: ''
    Type: String
  FIXClientCIDRs:
    Default: 10.10.0.0/20
    Description: The comma-delimited external CIDR ranges that should be granted access
      to your ingestion endpoint. (Max. 5)
    Type: CommaDelimitedList
  FIXServerDNSName:
    Default: ''
    Description: If you are the acceptor, this will be the domain name created that
      points to your Global Accelerator Endpoint (e.g., fix.example.com)
    Type: String
  FIXServerPort:
    Default: 9877
    Description: Port number used to create FIX connection.
    MaxValue: 65535
    MinValue: 1
    Type: Number
  FIXVersion:
    AllowedValues:
      - '4.0'
      - '4.1'
      - '4.2'
      - '4.3'
      - '4.4'
      - '5.0'
    Default: '4.2'
    Description: The desired FIX engine version.
    Type: String
  FailoverPrivateSubnet:
    Description: The private subnet you wish to use for your failover compute and
      data resources.
    Type: AWS::EC2::Subnet::Id
  FailoverPublicSubnet:
    Description: The public subnet you wish to use for your failover Network Load
      Balancer.
    Type: AWS::EC2::Subnet::Id
  HostedZoneID:
    Default: ''
    Description: '[Required for Acceptor Stack] If you are the acceptor, this should
      be the Hosted Zone ID for the domain hosted in Route53.'
    Type: String
  KafkaConnTLS:
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'
    Description: Choose True to enable TLS encryption for your Kafka connection
    Type: String
  LogRetentionInDays:
    AllowedValues:
      - '1'
      - '7'
      - '14'
      - '30'
      - '60'
      - '90'
      - '120'
      - '180'
      - '365'
    Default: '30'
    Description: The number of days CloudWatch-bound application logs should be kept.
    Type: String
  PrimaryPrivateSubnet:
    Description: The private subnet you wish to use for your primary compute and data
      resources.
    Type: AWS::EC2::Subnet::Id
  PrimaryPublicSubnet:
    Description: The public subnet you wish to use for your primary Network Load Balancer.
    Type: AWS::EC2::Subnet::Id
  S3LogsBucket:
    Default: ''
    Description: >-
      [Optional] The S3 Bucket you wish to use for S3-bound application logs (e.g.,
      Network Load Balancer). Please ensure your bucket policy is configured to allow
      delivery from your NLBs: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-access-logs.html#access-logging-bucket-permissions
    Type: String
  S3LogsBucketPrefix:
    Default: hello
    Description: '[Optional] The S3 Key prefix you wish to use for S3-bound application
      logs.'
    Type: String
  SNSTopicArn:
    Default: ''
    Description: '[Optional] The SNS Topic ARN you would like alerts sent to related
      to the resources in this stack.'
    Type: String
  SenderCompID:
    Default: server
    Description: ''
    Type: String
  TargetCompID:
    Default: client
    Description: Computer ID used to initiate FIX communication
    Type: String
  UserApplicationCIDRs:
    Default: 10.10.0.0/20
    Description: The comma-delimited private CIDR ranges corresponding to the user
      application that should be granted access to your MSK endpoint. (Max. 5)
    Type: CommaDelimitedList
  VPC:
    Description: The VPC into which these resources should be launched.
    Type: AWS::EC2::VPC::Id
Resources:
  ApplicationIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX Application ID for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - ApplicationID
      Tier: Standard
      Type: String
      Value: !Ref 'ApplicationID'
    Type: AWS::SSM::Parameter
  AutomationDocumentStarterFunction:
    Condition: ''
    DependsOn:
      - AutomationDocumentStarterRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport time\nimport boto3\nimport logging\nimport cfnresponse\n\
          from botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\n\
          LOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\nssm_client = boto3.client('ssm')\n\
          \ndef start_document(properties):\n    \n    try:\n        \n        response\
          \ = ssm_client.start_automation_execution(\n            Parameters = {\n\
          \                'ExecutionRoleArn': [\n                    properties['ExecutionRoleArn']\n\
          \                ]\n            },\n            DocumentName = properties['AutomationDocumentName'],\n\
          \        )\n    \n        return True\n    \n    except ClientError as e:\n\
          \        print(str(e)); return False\n\n'''\n    - ExecutionRoleArn | str\n\
          \    - EligibleRequestTypes | list\n    - AutomationDocumentName | str\n\
          '''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST RECEIVED\
          \ -----')\n    LOGGER.info(json.dumps(event))\n    \n    responseData =\
          \ {}\n\n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if\
          \ 'EligibleRequestTypes' not in properties:\n        properties['EligibleRequestTypes']\
          \ = ['Create']\n    \n    if event['RequestType'] in properties['EligibleRequestTypes']:\n\
          \        \n        attempt_cnt = 0\n        while attempt_cnt < 5:\n   \
          \         \n            if attempt_cnt > 0:\n                time.sleep(10)\n\
          \            \n            if start_document(properties) is True:\n    \
          \            return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData, properties['AutomationDocumentName'])\n        \n      \
          \      attempt_cnt += 1\n            \n        return cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, responseData)\n    \n    elif event['RequestType']\
          \ not in properties['EligibleRequestTypes']:\n        \n        return cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, responseData)"
      Description: !Join
        - ''
        - - 'AutomationDocumentStarter resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'AutomationDocumentStarterRole.Arn'
      Runtime: python3.7
      Timeout: 180
    Type: AWS::Lambda::Function
  AutomationDocumentStarterLogGroup:
    Condition: ''
    DependsOn:
      - AutomationDocumentStarterFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'AutomationDocumentStarterFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  AutomationDocumentStarterRole:
    Condition: ''
    DependsOn: []
    Metadata: {}
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies: []
    Type: AWS::IAM::Role
  CloudWatchDashboard:
    Properties:
      DashboardBody: !Sub
        - "{\n   \"start\": \"-PT3H\",\n   \"periodOverride\": \"inherit\",\n    \"\
          widgets\": [\n        {\n            \"type\": \"metric\",\n           \
          \ \"properties\": {\n                \"view\": \"timeSeries\",\n       \
          \         \"width\": 20,\n                \"height\": 12,\n            \
          \    \"title\": \"Fargate Resource Utlization\",\n                \"period\"\
          : 300,\n                \"stacked\": false,\n                \"metrics\"\
          : [\n                    [\n                        \"AWS/ECS\", \n    \
          \                    \"MemoryUtilization\", \n                        \"\
          ServiceName\", \n                        \"${PRIMARY_ECS_SERVICE_NAME}\"\
          ,\n                        \"ClusterName\", \n                        \"\
          ${PRIMARY_ECS_CLUSTER_NAME}\",\n                        {\n            \
          \                \"label\": \"PrimaryMemUtilization\"\n                \
          \        }\n                    ],\n                    [ \n           \
          \             \"AWS/ECS\", \n                        \"CPUUtilization\"\
          , \n                        \"ServiceName\", \n                        \"\
          ${PRIMARY_ECS_SERVICE_NAME}\",\n                        \"ClusterName\"\
          , \n                        \"${PRIMARY_ECS_CLUSTER_NAME}\",\n         \
          \               {\n                            \"label\": \"PrimaryCPUUtilization\"\
          \n                        }\n                    ],\n                  \
          \  [\n                        \"AWS/ECS\", \n                        \"\
          MemoryUtilization\", \n                        \"ServiceName\", \n     \
          \                   \"${FAILOVER_ECS_SERVICE_NAME}\",\n                \
          \        \"ClusterName\", \n                        \"${FAILOVER_ECS_CLUSTER_NAME}\"\
          ,\n                        {\n                            \"label\": \"\
          FailoverMemUtilization\"\n                        }\n                  \
          \  ],\n                    [ \n                        \"AWS/ECS\", \n \
          \                       \"CPUUtilization\", \n                        \"\
          ServiceName\", \n                        \"${FAILOVER_ECS_SERVICE_NAME}\"\
          ,\n                        \"ClusterName\", \n                        \"\
          ${FAILOVER_ECS_CLUSTER_NAME}\",\n                        {\n           \
          \                 \"label\": \"FailoverCPUUtilization\"\n              \
          \          }\n                    ]\n                ],\n              \
          \  \"region\": \"us-east-1\"\n            }\n        }\n    ]\n}"
        - FAILOVER_ECS_CLUSTER_NAME: !Ref 'FailoverECSCluster'
          FAILOVER_ECS_SERVICE_NAME: !If
            - IsInitiatorStack
            - !Ref 'FailoverInitiatorECSService'
            - !Ref 'FailoverAcceptorECSService'
          PRIMARY_ECS_CLUSTER_NAME: !Ref 'PrimaryECSCluster'
          PRIMARY_ECS_SERVICE_NAME: !If
            - IsInitiatorStack
            - !Ref 'PrimaryInitiatorECSService'
            - !Ref 'PrimaryAcceptorECSService'
    Type: AWS::CloudWatch::Dashboard
  ConnectionTypeParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine connection type defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - ConnectionType
      Tier: Standard
      Type: String
      Value: !Ref 'ConnectionType'
    Type: AWS::SSM::Parameter
  DebugLoggingParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX debug logging setting defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - DebugLogging
      Tier: Standard
      Type: String
      Value: !Ref 'DebugLogging'
    Type: AWS::SSM::Parameter
  ECRRepository:
    DependsOn:
      - StackNameManipulator
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: ECR does not allow capital letters in repository names which is
              why we must sanitize/lowercase the auto-generated name.
    Properties:
      ImageScanningConfiguration:
        ScanOnPush: true
      RepositoryName: !Join
        - ''
        - - fix-engine-on-aws/
          - !GetAtt 'StackNameManipulator.OutputString'
    Type: AWS::ECR::Repository
  ECSImageBuildDocument:
    DependsOn:
      - ECRRepository
      - ECSImageBuildSecurityGroup
      - ECSImageBuildExecutionRole
      - ECSImageBuildInstanceRoleProfile
    Properties:
      Content:
        assumeRole: '{{ExecutionRoleArn}}'
        description: !Join
          - ''
          - - 'Creates the client and server images use by CloudFormation stack '
            - !Ref 'AWS::StackName'
        mainSteps:
          - action: aws:runInstances
            inputs:
              BlockDeviceMappings:
                - DeviceName: /dev/sda1
                  Ebs:
                    Encrypted: true
                    VolumeSize: 8
                    VolumeType: gp2
              IamInstanceProfileName: !Ref 'ECSImageBuildInstanceRoleProfile'
              ImageId: '{{LatestAmazonLinux2AMIId}}'
              InstanceType: t3a.small
              MaxInstanceCount: 1
              MinInstanceCount: 1
              SecurityGroupIds:
                - !Ref 'ECSImageBuildSecurityGroup'
              SubnetId: !Ref 'PrimaryPrivateSubnet'
              TagSpecifications:
                - ResourceType: instance
                  Tags:
                    - Key: Name
                      Value: !Join
                        - '-'
                        - - !Ref 'AWS::StackName'
                          - ECSImageBuilder
                    - Key: LaunchedBy
                      Value: SSMAutomation
                    - Key: StackName
                      Value: !Ref 'AWS::StackName'
            maxAttempts: 3
            name: LaunchInstance
            onFailure: step:SignalFailure
            timeoutSeconds: 300
          - action: aws:runCommand
            inputs:
              CloudWatchOutputConfig:
                CloudWatchLogGroupName: !Ref 'ECSImageBuildLogGroup'
                CloudWatchOutputEnabled: true
              DocumentName: AWS-RunShellScript
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Parameters:
                commands:
                  - sudo yum update
                  - sudo yum install jq git docker java-1.8.0-openjdk-devel -y
                  - '# Installs Gradle'
                  - sudo wget -c https://services.gradle.org/distributions/gradle-6.6.1-all.zip
                  - sudo unzip gradle-6.6.1-all.zip -d /opt
                  - sudo ln -s /opt/gradle-6.6.1 /opt/gradle
                  - export GRADLE_HOME=/opt/gradle
                  - export PATH=$PATH:\/opt/gradle/bin
                  - cd /tmp
                  - git clone https://github.com/aws-samples/amazon-resilient-fix-engine-demo.git
                  - cd amazon-resilient-fix-engine-demo
                  - !Join
                    - ' '
                    - - sh scripts/dockerbuild.sh --ecr-repo-name
                      - !Ref 'ECRRepository'
                      - --engine-role
                      - !If
                        - IsAcceptorStack
                        - Server
                        - Client
            name: BuildECSImage
            onFailure: step:TerminateInstanceOnFailure
            timeoutSeconds: 1800
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: ECSImageBuildWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: SUCCESS
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnFailure
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: ECSImageBuildWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: FAILURE
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalFailure
        parameters:
          ExecutionRoleArn:
            default: !GetAtt 'ECSImageBuildExecutionRole.Arn'
            description: The service role to use for this automation.
            type: String
          LatestAmazonLinux2AMIId:
            default: '{{ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs}}'
            description: The latest Amazon Linux 2 AMI queried from the public parameter.
            type: String
        schemaVersion: '0.3'
      DocumentType: Automation
    Type: AWS::SSM::Document
  ECSImageBuildExecutionRole:
    DependsOn:
      - ECSImageBuildInstanceRole
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ::image/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :subnet/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :security-group/
                      - !GetAtt 'MSKClusterPrepSecurityGroup.GroupId'
              - Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !GetAtt 'ECSImageBuildInstanceRole.Arn'
              - Action:
                  - cloudformation:SignalResource
                Effect: Allow
                Resource:
                  - !Ref 'AWS::StackId'
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  ECSImageBuildInstanceRole:
    DependsOn:
      - ECRRepository
      - ECSImageBuildLogGroup
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: ecr:GetAuthorizationToken does not support resource filtering.
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ecr:PutImage
                  - ecr:UploadLayerPart
                  - ecr:InitiateLayerUpload
                  - ecr:CompleteLayerUpload
                  - ecr:BatchCheckLayerAvailability
                Effect: Allow
                Resource:
                  - !GetAtt 'ECRRepository.Arn'
              - Action:
                  - ecr:GetAuthorizationToken
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'ECSImageBuildLogGroup'
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'ECSImageBuildLogGroup'
                      - :log-stream:*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  ECSImageBuildInstanceRoleProfile:
    DependsOn:
      - ECSImageBuildInstanceRole
    Properties:
      Path: /
      Roles:
        - !Ref 'ECSImageBuildInstanceRole'
    Type: AWS::IAM::InstanceProfile
  ECSImageBuildLogGroup:
    Properties:
      LogGroupName: !Join
        - /
        - - /aws/ssm
          - !Ref 'AWS::StackName'
          - ECSImageBuild
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  ECSImageBuildPolicy:
    DependsOn:
      - AutomationDocumentStarterRole
      - ECSImageBuildDocument
      - ECSImageBuildExecutionRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt 'ECSImageBuildExecutionRole.Arn'
          - Action:
              - ssm:StartAutomationExecution
            Effect: Allow
            Resource:
              - !Join
                - ''
                - - 'arn:aws:ssm:'
                  - !Ref 'AWS::Region'
                  - ':'
                  - !Ref 'AWS::AccountId'
                  - :automation-definition/
                  - !Ref 'ECSImageBuildDocument'
                  - :$DEFAULT
      PolicyName: ECSImageBuildPolicy
      Roles:
        - !Ref 'AutomationDocumentStarterRole'
    Type: AWS::IAM::Policy
  ECSImageBuildSecurityGroup:
    DependsOn: []
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W5
            reason: Outbound HTTP(S) traffic is required to download third-party dependencies.
    Properties:
      GroupDescription: Security Group for EC2 Instances Launched via SSM Automation
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: All HTTP Traffic
          FromPort: 80
          IpProtocol: tcp
          ToPort: 80
        - CidrIp: '0.0.0.0/0'
          Description: Allow All HTTPS Traffic
          FromPort: 443
          IpProtocol: tcp
          ToPort: 443
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  ECSImageBuildStarter:
    DependsOn:
      - ECRRepository
      - ECSImageBuildPolicy
      - ECSImageBuildDocument
      - AutomationDocumentStarterLogGroup
    Properties:
      Properties:
        AutomationDocumentName: !Ref 'ECSImageBuildDocument'
        EligibleRequestTypes:
          - Create
          - Update
        ExecutionRoleArn: !GetAtt 'ECSImageBuildExecutionRole.Arn'
        RepositoryName: !Ref 'ECRRepository'
        TemplateVersion: '1.34'
      ServiceToken: !GetAtt 'AutomationDocumentStarterFunction.Arn'
      Type: Custom::StartSSMAutomationDocument
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  ECSImageBuildWaiter:
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT20M
    DependsOn:
      - ECSImageBuildPolicy
      - ECSImageBuildDocument
      - AutomationDocumentStarterLogGroup
    Type: AWS::CloudFormation::WaitCondition
  ECSImageRemover:
    DependsOn:
      - ECRRepository
      - ECSImageRemoverLogGroup
    Properties:
      Properties:
        RepositoryName: !Ref 'ECRRepository'
      ServiceToken: !GetAtt 'ECSImageRemoverFunction.Arn'
      Type: Custom::ECSImageRemover
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  ECSImageRemoverFunction:
    Condition: ''
    DependsOn:
      - ECSImageRemoverRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\n\
          from botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\n\
          LOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - RepositoryName\
          \ | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST\
          \ RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData\
          \ = {}\n\n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if\
          \ event['RequestType'] in ['Delete']:\n        \n        ecr_client = boto3.client('ecr')\n\
          \n        try:\n            \n            existing_images = ecr_client.describe_images(\n\
          \                repositoryName = properties['RepositoryName']\n       \
          \     )\n            \n            if len(existing_images['imageDetails'])\
          \ > 0:\n                \n                images_to_delete = []\n      \
          \          for image in existing_images['imageDetails']:\n             \
          \       \n                    images_to_delete.append({\n              \
          \          'imageDigest': image['imageDigest']\n                    })\n\
          \                    \n                ecr_client.batch_delete_image(\n\
          \                    repositoryName = properties['RepositoryName'],\n  \
          \                  imageIds = images_to_delete\n                )\n    \
          \            \n            return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData, properties['RepositoryName'])\n            \n        except\
          \ ClientError as e:\n        \n            print(str(e))\n            return\
          \ cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n \
          \   \n    elif event['RequestType'] in ['Create', 'Update']:\n        \n\
          \        return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)"
      Description: !Join
        - ''
        - - 'ECSImageRemover resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'ECSImageRemoverRole.Arn'
      Runtime: python3.7
      Timeout: 15
    Type: AWS::Lambda::Function
  ECSImageRemoverLogGroup:
    Condition: ''
    DependsOn:
      - ECSImageRemoverFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'ECSImageRemoverFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  ECSImageRemoverRole:
    Condition: ''
    DependsOn:
      - ECRRepository
    Metadata: {}
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ecr:DescribeImages
                  - ecr:BatchDeleteImage
                Effect: Allow
                Resource:
                  - !GetAtt 'ECRRepository.Arn'
          PolicyName: PrimaryPolicy
    Type: AWS::IAM::Role
  FIXClientPrefixListUpdater:
    DependsOn:
      - FIXClientVPCPrefixList
      - VPCPrefixListManagerLogGroup
    Properties:
      Properties:
        AuthorizedCidrs: !Ref 'FIXClientCIDRs'
        EntryDescription: !Join
          - ''
          - - 'Authorized FIX Client CIDR in '
            - !Ref 'AWS::StackName'
            - ' stack'
        PrefixListId: !Ref 'FIXClientVPCPrefixList'
      ServiceToken: !GetAtt 'VPCPrefixListManagerFunction.Arn'
      Type: Custom::UpdateFIXClientPrefixList
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  FIXClientVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      MaxEntries: 5
      PrefixListName: !Join
        - ''
        - - !Ref 'AWS::StackName'
          - '-'
          - FIXClientCIDRs
    Type: AWS::EC2::PrefixList
  FIXServerDNSNameParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Socket connection host for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXServerDNSName
      Tier: Standard
      Type: String
      Value: !If
        - FIXServerDNSNameSupplied
        - !Ref 'FIXServerDNSName'
        - None
    Type: AWS::SSM::Parameter
  FIXServerPortParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine server port defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXServerPort
      Tier: Standard
      Type: String
      Value: !Ref 'FIXServerPort'
    Type: AWS::SSM::Parameter
  FIXVersionIntParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine version as integer for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXVersionInt
      Tier: Standard
      Type: String
      Value: !Join
        - ''
        - !Split
          - .
          - !Ref 'FIXVersion'
    Type: AWS::SSM::Parameter
  FIXVersionParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine version for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FIXVersion
      Tier: Standard
      Type: String
      Value: !Ref 'FIXVersion'
    Type: AWS::SSM::Parameter
  FailoverAcceptorECSService:
    Condition: IsAcceptorStack
    DependsOn:
      - FailoverECSCluster
      - FargateSecurityGroup
      - FailoverAcceptorECSTaskDefinition
      - FailoverTargetGroup
      - FailoverNLBListener
    Properties:
      Cluster: !Ref 'FailoverECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Ref 'AWS::StackName'
          ContainerPort: !Ref 'FIXServerPort'
          TargetGroupArn: !Ref 'FailoverTargetGroup'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'FailoverPrivateSubnet'
      TaskDefinition: !Ref 'FailoverAcceptorECSTaskDefinition'
    Type: AWS::ECS::Service
  FailoverAcceptorECSTaskDefinition:
    Condition: IsAcceptorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - FargateExecutionRole
      - MSKClusterInfoRetriever
      - RDSClusterNonAdminSecret
      - ECSImageBuildWaiter
      - GlobalAccelerator
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: PRIMARY_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
            - Name: FAILOVER_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
            - Name: GLOBAL_ACCELERATOR_ARN
              Value: !If
                - IsAcceptorStack
                - !GetAtt 'GlobalAccelerator.AcceleratorArn'
                - ''
            - Name: GLOBAL_ACCELERATOR_ENDPOINT_ARN
              Value: !If
                - IsAcceptorStack
                - !Ref 'FailoverNLB'
                - ''
          Essential: 'true'
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Failover
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  FailoverECSCluster:
    Type: AWS::ECS::Cluster
  FailoverInitiatorECSService:
    Condition: IsInitiatorStack
    DependsOn:
      - FailoverECSCluster
      - FargateSecurityGroup
      - FailoverInitiatorECSTaskDefinition
    Properties:
      Cluster: !Ref 'FailoverECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'FailoverPrivateSubnet'
      TaskDefinition: !Ref 'FailoverInitiatorECSTaskDefinition'
    Type: AWS::ECS::Service
  FailoverInitiatorECSTaskDefinition:
    Condition: IsInitiatorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - FargateExecutionRole
      - MSKClusterInfoRetriever
      - RDSClusterNonAdminSecret
      - ECSImageBuildWaiter
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: PRIMARY_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
            - Name: FAILOVER_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
          Essential: 'true'
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Failover
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  FailoverMSKEndpointParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Failover MSK endpoint FQDN for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - FailoverMSKEndpoint
      Tier: Standard
      Type: String
      Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
    Type: AWS::SSM::Parameter
  FailoverNLB:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      IpAddressType: ipv4
      LoadBalancerAttributes: !If
        - SendLogsToS3
        - - Key: access_logs.s3.enabled
            Value: 'true'
          - Key: access_logs.s3.bucket
            Value: !Ref 'S3LogsBucket'
          - Key: access_logs.s3.prefix
            Value: ''
        - - Key: access_logs.s3.enabled
            Value: 'false'
      Scheme: internet-facing
      Subnets:
        - !Ref 'FailoverPublicSubnet'
      Type: network
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  FailoverNLBListener:
    Condition: IsAcceptorStack
    DependsOn:
      - FailoverNLB
      - FailoverTargetGroup
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'FailoverTargetGroup'
          Type: forward
      LoadBalancerArn: !Ref 'FailoverNLB'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::ElasticLoadBalancingV2::Listener
  FailoverRDSInstance:
    DependsOn:
      - RDSCluster
      - RDSParameterGroup
      - RDSClusterErrorLogGroup
    Properties:
      AllowMajorVersionUpgrade: 'false'
      AutoMinorVersionUpgrade: 'true'
      CopyTagsToSnapshot: 'true'
      DBClusterIdentifier: !Ref 'RDSCluster'
      DBInstanceClass: db.r4.2xlarge
      DBParameterGroupName: !Ref 'RDSParameterGroup'
      EnablePerformanceInsights: 'false'
      Engine: aurora
      MultiAZ: 'false'
      PubliclyAccessible: 'false'
    Type: AWS::RDS::DBInstance
  FailoverTargetGroup:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      HealthCheckEnabled: 'true'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
      TargetGroupAttributes:
        - Key: stickiness.type
          Value: source_ip
        - Key: stickiness.enabled
          Value: 'false'
      TargetType: ip
      VpcId: !Ref 'VPC'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  FargateExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
    Type: AWS::IAM::Role
  FargateLogGroup:
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/ecs/fargate/
          - !Ref 'AWS::StackName'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  FargateSecurityGroup:
    DependsOn:
      - Route53HealthCheckVPCPrefixList
    Properties:
      GroupDescription: Security Group for Fargate Tasks
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: Allow All TCP Traffic
          FromPort: 1
          IpProtocol: tcp
          ToPort: 65535
      SecurityGroupIngress:
        - Description: FIX Engine Access for FIX Clients
          FromPort: !If
            - IsAcceptorStack
            - !Ref 'FIXServerPort'
            - 32768
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'FIXClientVPCPrefixList'
          ToPort: !If
            - IsAcceptorStack
            - !Ref 'FIXServerPort'
            - 65535
        - Description: AWS Route53 Health Checks
          FromPort: !Ref 'FIXServerPort'
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'Route53HealthCheckVPCPrefixList'
          ToPort: !Ref 'FIXServerPort'
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  FargateTaskRole:
    DependsOn:
      - RDSClusterNonAdminSecret
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
      ManagedPolicyArns: []
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource:
                  - !Join
                    - '-'
                    - - !Select
                        - 0
                        - !Split
                          - '-'
                          - !Ref 'RDSClusterNonAdminSecret'
                      - !Select
                        - 1
                        - !Split
                          - '-'
                          - !Ref 'RDSClusterNonAdminSecret'
                      - !Select
                        - 2
                        - !Split
                          - '-'
                          - !Ref 'RDSClusterNonAdminSecret'
                      - !Select
                        - 3
                        - !Split
                          - '-'
                          - !Ref 'RDSClusterNonAdminSecret'
                  - !Ref 'RDSClusterNonAdminSecret'
              - Action:
                  - ssm:GetParameter
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ssm:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :parameter/fixengine/
                      - !Ref 'AWS::StackName'
                      - /*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  FargateTaskRoleGAPolicy:
    Condition: IsAcceptorStack
    DependsOn:
      - FargateTaskRole
      - GlobalAcceleratorEndpointGroup
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - globalaccelerator:UpdateEndpointGroup
              - globalaccelerator:DescribeEndpointGroup
            Effect: Allow
            Resource:
              - !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
      PolicyName: global-accelerator-access
      Roles:
        - !Ref 'FargateTaskRole'
    Type: AWS::IAM::Policy
  GlobalAccelerator:
    Condition: IsAcceptorStack
    Properties:
      Enabled: 'true'
      Name: !Ref 'AWS::StackName'
    Type: AWS::GlobalAccelerator::Accelerator
  GlobalAcceleratorArnParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator ARN for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorArn
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAccelerator.AcceleratorArn'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorDNSNameParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator DNS name for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorDNSName
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAccelerator.DnsName'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorDNSRecord:
    Condition: CreateEndpointRecord
    DependsOn:
      - GlobalAccelerator
    Properties:
      HostedZoneId: !Ref 'HostedZoneID'
      RecordSets:
        - AliasTarget:
            DNSName: !GetAtt 'GlobalAccelerator.DnsName'
            HostedZoneId: Z2BJ6XQ5FK7U4H
          Name: !Ref 'FIXServerDNSName'
          Type: A
    Type: AWS::Route53::RecordSetGroup
  GlobalAcceleratorEndpointGroup:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryNLB
      - FailoverNLB
      - GlobalAcceleratorListener
    Properties:
      EndpointConfigurations:
        - EndpointId: !Ref 'PrimaryNLB'
          Weight: 100
        - EndpointId: !Ref 'FailoverNLB'
          Weight: 0
      EndpointGroupRegion: !Ref 'AWS::Region'
      ListenerArn: !Ref 'GlobalAcceleratorListener'
    Type: AWS::GlobalAccelerator::EndpointGroup
  GlobalAcceleratorEndpointGroupArnParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator Group Endpoint ARN for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorEndpointGroupArn
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAcceleratorEndpointGroup.EndpointGroupArn'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorIPAddressesParam:
    Condition: IsAcceptorStack
    Properties:
      Description: !Join
        - ''
        - - 'Global Accelerator IP addresses for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - GlobalAcceleratorIPAddresses
      Tier: Standard
      Type: String
      Value: !GetAtt 'GlobalAcceleratorInfoRetriever.IPAddresses'
    Type: AWS::SSM::Parameter
  GlobalAcceleratorInfoRetriever:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAccelerator
      - GlobalAcceleratorInfoRetrieverLogGroup
    Properties:
      Properties:
        AcceleratorArn: !Ref 'GlobalAccelerator'
      ServiceToken: !GetAtt 'GlobalAcceleratorInfoRetrieverFunction.Arn'
      Type: Custom::GetAcceleratorInfo
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  GlobalAcceleratorInfoRetrieverFunction:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAcceleratorInfoRetrieverRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\n\
          from botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\n\
          LOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - AcceleratorArn\
          \ | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST\
          \ RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData\
          \ = {}\n    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if\
          \ event['RequestType'] in ['Create', 'Update']:\n\n        accelerator_client\
          \ = boto3.client('globalaccelerator', region_name = 'us-west-2')\n\n   \
          \     try:\n\n            response = accelerator_client.describe_accelerator(\n\
          \                AcceleratorArn = properties['AcceleratorArn']\n       \
          \     )\n\n            if 'Accelerator' not in response:\n\n           \
          \     return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n\
          \n            else:\n\n                responseData['IPAddresses'] = ','.join(response['Accelerator']['IpSets'][0]['IpAddresses'])\n\
          \                return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData, properties['AcceleratorArn'])\n\n        except ClientError\
          \ as e:\n            print(str(e))\n            return cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, responseData)\n            \n    elif event['RequestType']\
          \ in ['Delete']:\n        \n        return cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, responseData)"
      Description: !Join
        - ''
        - - 'GlobalAcceleratorInfoRetriever resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'GlobalAcceleratorInfoRetrieverRole.Arn'
      Runtime: python3.7
      Timeout: 15
    Type: AWS::Lambda::Function
  GlobalAcceleratorInfoRetrieverLogGroup:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAcceleratorInfoRetrieverFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'GlobalAcceleratorInfoRetrieverFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  GlobalAcceleratorInfoRetrieverRole:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAccelerator
    Metadata: {}
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - globalaccelerator:DescribeAccelerator
                Effect: Allow
                Resource:
                  - !GetAtt 'GlobalAccelerator.AcceleratorArn'
          PolicyName: PrimaryPolicy
    Type: AWS::IAM::Role
  GlobalAcceleratorListener:
    Condition: IsAcceptorStack
    DependsOn:
      - GlobalAccelerator
    Properties:
      AcceleratorArn: !Ref 'GlobalAccelerator'
      ClientAffinity: NONE
      PortRanges:
        - FromPort: !Ref 'FIXServerPort'
          ToPort: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::GlobalAccelerator::Listener
  KafkaConnTLSParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Kafka TLS connection setting for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - KafkaConnTLS
      Tier: Standard
      Type: String
      Value: !Ref 'KafkaConnTLS'
    Type: AWS::SSM::Parameter
  KafkaPortParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Kafka connection port for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - KafkaPort
      Tier: Standard
      Type: String
      Value: !If
        - KafkaTLSEnabled
        - '9094'
        - '9092'
    Type: AWS::SSM::Parameter
  MSKCluster:
    DependsOn:
      - MSKClusterSecurityGroup
    Properties:
      BrokerNodeGroupInfo:
        BrokerAZDistribution: DEFAULT
        ClientSubnets:
          - !Ref 'PrimaryPrivateSubnet'
          - !Ref 'FailoverPrivateSubnet'
        InstanceType: kafka.m5.large
        SecurityGroups:
          - !Ref 'MSKClusterSecurityGroup'
        StorageInfo:
          EBSStorageInfo:
            VolumeSize: 100
      ClusterName: !Ref 'AWS::StackName'
      EncryptionInfo:
        EncryptionInTransit:
          ClientBroker: TLS_PLAINTEXT
          InCluster: 'true'
      KafkaVersion: 2.2.1
      NumberOfBrokerNodes: 2
    Type: AWS::MSK::Cluster
  MSKClusterInfoRetriever:
    DependsOn:
      - MSKCluster
      - MSKClusterInfoRetrieverLogGroup
    Properties:
      Properties:
        ClusterARN: !Ref 'MSKCluster'
      ServiceToken: !GetAtt 'MSKClusterInfoRetrieverFunction.Arn'
      Type: Custom::GetMSKClusterInfo
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  MSKClusterInfoRetrieverFunction:
    Condition: ''
    DependsOn:
      - MSKClusterInfoRetrieverRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\n\
          from botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\n\
          LOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - ClusterARN\
          \ | str\n'''\ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST\
          \ RECEIVED -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData\
          \ = {}\n    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if\
          \ operation == 'GetMSKClusterInfo':\n        \n        if event['RequestType']\
          \ in ['Create', 'Update']:\n        \n            msk_client = boto3.client('kafka')\n\
          \        \n            try:\n        \n                nodes = msk_client.list_nodes(\n\
          \                    ClusterArn = properties['ClusterARN']\n           \
          \     )\n        \n                if 'NodeInfoList' not in nodes or len(nodes['NodeInfoList'])\
          \ == 0:\n        \n                    return cfnresponse.send(event, context,\
          \ cfnresponse.FAILED, responseData)\n        \n                else:\n \
          \       \n                    for node in nodes['NodeInfoList']:\n     \
          \   \n                        if node['BrokerNodeInfo']['BrokerId'] == 1:\n\
          \        \n                            responseData['PrimaryEndpoint'] =\
          \ node['BrokerNodeInfo']['Endpoints'][0]\n        \n                   \
          \     else:\n        \n                            responseData['FailoverEndpoint']\
          \ = node['BrokerNodeInfo']['Endpoints'][0]\n        \n                 \
          \   return cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData,\
          \ properties['ClusterARN'])\n        \n            except ClientError as\
          \ e:\n                \n                print(str(e))\n                return\
          \ cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n \
          \       \n        elif event['RequestType'] in ['Delete']:\n        \n \
          \           return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData)"
      Description: !Join
        - ''
        - - 'MSKClusterInfoRetriever resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'MSKClusterInfoRetrieverRole.Arn'
      Runtime: python3.7
      Timeout: 15
    Type: AWS::Lambda::Function
  MSKClusterInfoRetrieverLogGroup:
    Condition: ''
    DependsOn:
      - MSKClusterInfoRetrieverFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'MSKClusterInfoRetrieverFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  MSKClusterInfoRetrieverRole:
    Condition: ''
    DependsOn:
      - MSKCluster
    Metadata: {}
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - kafka:ListNodes
                Effect: Allow
                Resource:
                  - !Ref 'MSKCluster'
          PolicyName: PrimaryPolicy
    Type: AWS::IAM::Role
  MSKClusterInitializationStarter:
    DependsOn:
      - MSKClusterPrepPolicy
      - MSKInitializationDocument
      - AutomationDocumentStarterLogGroup
    Properties:
      Properties:
        AutomationDocumentName: !Ref 'MSKInitializationDocument'
        EligibleRequestTypes:
          - Create
        ExecutionRoleArn: !GetAtt 'MSKClusterPrepExecutionRole.Arn'
      ServiceToken: !GetAtt 'AutomationDocumentStarterFunction.Arn'
      Type: Custom::StartSSMAutomationDocument
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  MSKClusterInitializationWaiter:
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT15M
    DependsOn:
      - MSKClusterPrepPolicy
      - MSKInitializationDocument
      - AutomationDocumentStarterLogGroup
    Type: AWS::CloudFormation::WaitCondition
  MSKClusterMemoryAlarm:
    Condition: CreateAlarms
    DependsOn:
      - MSKCluster
    Properties:
      ActionsEnabled: 'true'
      AlarmActions:
        - !Ref 'SNSTopicArn'
      AlarmDescription: Alerts when MSK cluster's memory utilization exceeds 80%
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: Cluster Name
          Value: !Ref 'MSKCluster'
      EvaluationPeriods: 2
      MetricName: MemoryUsed
      Namespace: AWS/Kafka
      OKActions:
        - !Ref 'SNSTopicArn'
      Period: 60
      Statistic: Average
      Threshold: '80'
      TreatMissingData: notBreaching
    Type: AWS::CloudWatch::Alarm
  MSKClusterPrepExecutionRole:
    DependsOn:
      - MSKClusterPrepInstanceRole
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ::image/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :subnet/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :security-group/
                      - !GetAtt 'MSKClusterPrepSecurityGroup.GroupId'
              - Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !GetAtt 'MSKClusterPrepInstanceRole.Arn'
              - Action:
                  - cloudformation:SignalResource
                Effect: Allow
                Resource:
                  - !Ref 'AWS::StackId'
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  MSKClusterPrepInstanceRole:
    DependsOn:
      - MSKCluster
      - MSKClusterPrepLogGroup
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - kafka:DescribeCluster
                Effect: Allow
                Resource:
                  - !Ref 'MSKCluster'
              - Action:
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'MSKClusterPrepLogGroup'
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'MSKClusterPrepLogGroup'
                      - :log-stream:*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  MSKClusterPrepInstanceRoleProfile:
    DependsOn:
      - MSKClusterPrepInstanceRole
    Properties:
      Path: /
      Roles:
        - !Ref 'MSKClusterPrepInstanceRole'
    Type: AWS::IAM::InstanceProfile
  MSKClusterPrepLogGroup:
    Properties:
      LogGroupName: !Join
        - /
        - - /aws/ssm
          - !Ref 'AWS::StackName'
          - MSKPrepAutomation
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  MSKClusterPrepPolicy:
    DependsOn:
      - AutomationDocumentStarterRole
      - MSKInitializationDocument
      - MSKClusterPrepExecutionRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt 'MSKClusterPrepExecutionRole.Arn'
          - Action:
              - ssm:StartAutomationExecution
            Effect: Allow
            Resource:
              - !Join
                - ''
                - - 'arn:aws:ssm:'
                  - !Ref 'AWS::Region'
                  - ':'
                  - !Ref 'AWS::AccountId'
                  - :automation-definition/
                  - !Ref 'MSKInitializationDocument'
                  - :$DEFAULT
      PolicyName: MSKClusterPrepPolicy
      Roles:
        - !Ref 'AutomationDocumentStarterRole'
    Type: AWS::IAM::Policy
  MSKClusterPrepSecurityGroup:
    DependsOn: []
    Properties:
      GroupDescription: Security Group for MSK Cluster Prep
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: Allow All TCP Traffic
          FromPort: 1
          IpProtocol: tcp
          ToPort: 65535
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  MSKClusterSecurityGroup:
    DependsOn:
      - FargateSecurityGroup
      - MSKClusterPrepSecurityGroup
    Properties:
      GroupDescription: Security Group for MSK Cluster
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/32'
          Description: Deny All Traffic
          FromPort: 1
          IpProtocol: tcp
          ToPort: 1
      SecurityGroupIngress:
        - Description: MSK Access for Private User App Ranges
          FromPort: !If
            - KafkaTLSEnabled
            - 9094
            - 9092
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'UserApplicationVPCPrefixList'
          ToPort: !If
            - KafkaTLSEnabled
            - 9094
            - 9092
        - Description: Non TLS Communication
          FromPort: !If
            - KafkaTLSEnabled
            - 9094
            - 9092
          IpProtocol: tcp
          SourceSecurityGroupId: !Ref 'FargateSecurityGroup'
          ToPort: !If
            - KafkaTLSEnabled
            - 9094
            - 9092
        - Description: Zookeeper Administration
          FromPort: 2181
          IpProtocol: tcp
          SourceSecurityGroupId: !Ref 'MSKClusterPrepSecurityGroup'
          ToPort: 2181
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  MSKInitializationDocument:
    DependsOn:
      - MSKCluster
      - MSKClusterPrepExecutionRole
      - MSKClusterPrepSecurityGroup
      - MSKClusterPrepInstanceRoleProfile
    Properties:
      Content:
        assumeRole: '{{ExecutionRoleArn}}'
        description: !Join
          - ''
          - - 'Configures the MSK cluster by CloudFormation stack '
            - !Ref 'AWS::StackName'
        mainSteps:
          - action: aws:runInstances
            inputs:
              BlockDeviceMappings:
                - DeviceName: /dev/sda1
                  Ebs:
                    Encrypted: true
                    VolumeSize: 8
                    VolumeType: gp2
              IamInstanceProfileName: !Ref 'MSKClusterPrepInstanceRoleProfile'
              ImageId: '{{LatestAmazonLinux2AMIId}}'
              InstanceType: t3a.small
              MaxInstanceCount: 1
              MinInstanceCount: 1
              SecurityGroupIds:
                - !Ref 'MSKClusterPrepSecurityGroup'
              SubnetId: !Ref 'PrimaryPrivateSubnet'
              TagSpecifications:
                - ResourceType: instance
                  Tags:
                    - Key: Name
                      Value: !Join
                        - '-'
                        - - !Ref 'AWS::StackName'
                          - MSKInitializer
                    - Key: LaunchedBy
                      Value: SSMAutomation
                    - Key: StackName
                      Value: !Ref 'AWS::StackName'
            maxAttempts: 3
            name: LaunchInstance
            onFailure: step:SignalFailure
            timeoutSeconds: 300
          - action: aws:runCommand
            inputs:
              CloudWatchOutputConfig:
                CloudWatchLogGroupName: !Ref 'MSKClusterPrepLogGroup'
                CloudWatchOutputEnabled: true
              DocumentName: AWS-RunShellScript
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Parameters:
                commands:
                  - sudo yum -y update
                  - sudo yum -y install java-1.8.0-openjdk-devel
                  - sudo wget https://archive.apache.org/dist/kafka/2.2.1/kafka_2.12-2.2.1.tgz
                  - sudo tar -xzf kafka_2.12-2.2.1.tgz
                  - cd kafka_2.12-2.2.1
                  - !Join
                    - ''
                    - - 'ZOOKEEPER_CONN_STRING=$(aws kafka describe-cluster --region '
                      - !Ref 'AWS::Region'
                      - ' --cluster-arn "'
                      - !Ref 'MSKCluster'
                      - '" --query ''ClusterInfo.ZookeeperConnectString'' --output
                        text)'
                  - bin/kafka-topics.sh --create --zookeeper $ZOOKEEPER_CONN_STRING
                    --replication-factor 2 --partitions 1 --topic TO-FIX-ENGINE
                  - bin/kafka-topics.sh --create --zookeeper $ZOOKEEPER_CONN_STRING
                    --replication-factor 2 --partitions 1 --topic FROM-FIX-ENGINE
            name: CreateMSKTopics
            onFailure: step:TerminateInstanceOnFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: MSKClusterInitializationWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: SUCCESS
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnFailure
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: MSKClusterInitializationWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: FAILURE
              UniqueId: !Ref 'AWS::StackName'
            isEnd: true
            name: SignalFailure
        parameters:
          ExecutionRoleArn:
            default: !GetAtt 'MSKClusterPrepExecutionRole.Arn'
            description: The service role to use for this automation.
            type: String
          LatestAmazonLinux2AMIId:
            default: '{{ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs}}'
            description: The latest Amazon Linux 2 AMI queried from the public parameter.
            type: String
        schemaVersion: '0.3'
      DocumentType: Automation
    Type: AWS::SSM::Document
  MiscMethodsHandlerFunction:
    Condition: ''
    DependsOn:
      - MiscMethodsHandlerRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport logging\nimport cfnresponse\nfrom botocore.exceptions\
          \ import ClientError\n\nLOGGER = logging.getLogger()\nLOGGER.setLevel(logging.INFO)\n\
          \ndef handler(event, context):\n\n    LOGGER.info('----- REQUEST RECEIVED\
          \ -----')\n    LOGGER.info(json.dumps(event))\n\n    response_data = {}\n\
          \    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    if\
          \ event['RequestType'] in ['Create', 'Update']:\n        \n        if operation\
          \ == 'ManipulateString':\n            \n            action = properties['Action']\n\
          \            input_str = properties['InputString']\n            \n     \
          \       if action == 'lower':\n                sanitized_str = input_str.lower()\n\
          \                \n            elif action == 'upper':\n               \
          \ sanitized_str = input_str.upper()\n                \n            response_data['OutputString']\
          \ = sanitized_str\n            return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ response_data, sanitized_str)\n                \n    elif event['RequestType']\
          \ in ['Delete']:\n        \n        return cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, response_data)"
      Description: !Join
        - ''
        - - 'MiscMethodsHandler resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'MiscMethodsHandlerRole.Arn'
      Runtime: python3.7
      Timeout: 15
    Type: AWS::Lambda::Function
  MiscMethodsHandlerLogGroup:
    Condition: ''
    DependsOn:
      - MiscMethodsHandlerFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'MiscMethodsHandlerFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  MiscMethodsHandlerRole:
    Condition: ''
    DependsOn: []
    Metadata: {}
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies: []
    Type: AWS::IAM::Role
  PrimaryAcceptorECSService:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryECSCluster
      - FargateSecurityGroup
      - PrimaryAcceptorECSTaskDefinition
      - PrimaryTargetGroup
      - PrimaryNLBListener
    Properties:
      Cluster: !Ref 'PrimaryECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Ref 'AWS::StackName'
          ContainerPort: !Ref 'FIXServerPort'
          TargetGroupArn: !Ref 'PrimaryTargetGroup'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'PrimaryPrivateSubnet'
      TaskDefinition: !Ref 'PrimaryAcceptorECSTaskDefinition'
    Type: AWS::ECS::Service
  PrimaryAcceptorECSTaskDefinition:
    Condition: IsAcceptorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - FargateExecutionRole
      - MSKClusterInfoRetriever
      - RDSClusterNonAdminSecret
      - ECSImageBuildWaiter
      - GlobalAccelerator
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: PRIMARY_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
            - Name: FAILOVER_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
            - Name: GLOBAL_ACCELERATOR_ARN
              Value: !If
                - IsAcceptorStack
                - !GetAtt 'GlobalAccelerator.AcceleratorArn'
                - ''
            - Name: GLOBAL_ACCELERATOR_ENDPOINT_ARN
              Value: !If
                - IsAcceptorStack
                - !Ref 'PrimaryNLB'
                - ''
          Essential: 'true'
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Primary
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  PrimaryECSCluster:
    Type: AWS::ECS::Cluster
  PrimaryInitiatorECSService:
    Condition: IsInitiatorStack
    DependsOn:
      - PrimaryECSCluster
      - FargateSecurityGroup
      - PrimaryInitiatorECSTaskDefinition
    Properties:
      Cluster: !Ref 'PrimaryECSCluster'
      DesiredCount: 1
      LaunchType: FARGATE
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - !Ref 'FargateSecurityGroup'
          Subnets:
            - !Ref 'PrimaryPrivateSubnet'
      TaskDefinition: !Ref 'PrimaryInitiatorECSTaskDefinition'
    Type: AWS::ECS::Service
  PrimaryInitiatorECSTaskDefinition:
    Condition: IsInitiatorStack
    DependsOn:
      - ECRRepository
      - FargateLogGroup
      - FargateTaskRole
      - FargateExecutionRole
      - MSKClusterInfoRetriever
      - RDSClusterNonAdminSecret
      - ECSImageBuildWaiter
    Properties:
      ContainerDefinitions:
        - Environment:
            - Name: PRIMARY_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
            - Name: FAILOVER_MSK_ENDPOINT
              Value: !GetAtt 'MSKClusterInfoRetriever.FailoverEndpoint'
            - Name: APPLICATION_STACK_NAME
              Value: !Ref 'AWS::StackName'
          Essential: 'true'
          Image: !If
            - UseDefaultImage
            - !Join
              - ''
              - - !Ref 'AWS::AccountId'
                - .dkr.ecr.
                - !Ref 'AWS::Region'
                - .amazonaws.com/
                - !Ref 'ECRRepository'
                - :latest
            - !Ref 'CustomImagePath'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'FargateLogGroup'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Join
                - /
                - - !Ref 'AWS::StackName'
                  - Primary
          Name: !Ref 'AWS::StackName'
          PortMappings:
            - ContainerPort: !Ref 'FIXServerPort'
      Cpu: '512'
      ExecutionRoleArn: !GetAtt 'FargateExecutionRole.Arn'
      Memory: 1GB
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'FargateTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  PrimaryMSKEndpointParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'Primary MSK endpoint FQDN for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - PrimaryMSKEndpoint
      Tier: Standard
      Type: String
      Value: !GetAtt 'MSKClusterInfoRetriever.PrimaryEndpoint'
    Type: AWS::SSM::Parameter
  PrimaryNLB:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      IpAddressType: ipv4
      LoadBalancerAttributes: !If
        - SendLogsToS3
        - - Key: access_logs.s3.enabled
            Value: 'true'
          - Key: access_logs.s3.bucket
            Value: !Ref 'S3LogsBucket'
          - Key: access_logs.s3.prefix
            Value: ''
        - - Key: access_logs.s3.enabled
            Value: 'false'
      Scheme: internet-facing
      Subnets:
        - !Ref 'PrimaryPublicSubnet'
      Type: network
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  PrimaryNLBListener:
    Condition: IsAcceptorStack
    DependsOn:
      - PrimaryNLB
      - PrimaryTargetGroup
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'PrimaryTargetGroup'
          Type: forward
      LoadBalancerArn: !Ref 'PrimaryNLB'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
    Type: AWS::ElasticLoadBalancingV2::Listener
  PrimaryRDSInstance:
    DependsOn:
      - RDSCluster
      - RDSParameterGroup
      - RDSClusterErrorLogGroup
    Properties:
      AllowMajorVersionUpgrade: 'false'
      AutoMinorVersionUpgrade: 'true'
      CopyTagsToSnapshot: 'true'
      DBClusterIdentifier: !Ref 'RDSCluster'
      DBInstanceClass: db.r4.2xlarge
      DBParameterGroupName: !Ref 'RDSParameterGroup'
      EnablePerformanceInsights: 'false'
      Engine: aurora
      MultiAZ: 'false'
      PubliclyAccessible: 'false'
    Type: AWS::RDS::DBInstance
  PrimaryTargetGroup:
    Condition: IsAcceptorStack
    DependsOn: []
    Properties:
      HealthCheckEnabled: 'true'
      Port: !Ref 'FIXServerPort'
      Protocol: TCP
      TargetGroupAttributes:
        - Key: stickiness.type
          Value: source_ip
        - Key: stickiness.enabled
          Value: 'false'
      TargetType: ip
      VpcId: !Ref 'VPC'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  RDSCluster:
    DeletionPolicy: Snapshot
    DependsOn:
      - RDSClusterSubnetGroup
      - RDSClusterAdminSecret
      - RDSClusterSecurityGroup
      - RDSClusterParameterGroup
    Properties:
      DBClusterParameterGroupName: !Ref 'RDSClusterParameterGroup'
      DBSubnetGroupName: !Ref 'RDSClusterSubnetGroup'
      EnableCloudwatchLogsExports:
        - error
        - general
        - slowquery
        - audit
      EnableIAMDatabaseAuthentication: 'false'
      Engine: aurora
      EngineMode: multimaster
      EngineVersion: 5.6.10a
      MasterUserPassword: !Join
        - ''
        - - '{{resolve:secretsmanager:'
          - !Ref 'RDSClusterAdminSecret'
          - :SecretString:password}}
      MasterUsername: !Join
        - ''
        - - '{{resolve:secretsmanager:'
          - !Ref 'RDSClusterAdminSecret'
          - :SecretString:username}}
      StorageEncrypted: 'true'
      Tags: []
      VpcSecurityGroupIds:
        - !Ref 'RDSClusterSecurityGroup'
    Type: AWS::RDS::DBCluster
  RDSClusterAdminSecret:
    Properties:
      Description: !Join
        - ''
        - - 'Admin credentials for '
          - !Ref 'AWS::StackName'
          - ' RDS cluster'
      GenerateSecretString:
        ExcludeCharacters: '"@/\,*!#$%-[]()_:^&`<>;+='''
        ExcludeLowercase: 'false'
        ExcludeNumbers: 'false'
        ExcludePunctuation: 'true'
        ExcludeUppercase: 'false'
        GenerateStringKey: password
        IncludeSpace: 'false'
        PasswordLength: 16
        RequireEachIncludedType: 'true'
        SecretStringTemplate: '{"username": "FEAdmin"}'
    Type: AWS::SecretsManager::Secret
  RDSClusterAdminSecretAttachment:
    DependsOn:
      - RDSCluster
      - RDSClusterAdminSecret
    Properties:
      SecretId: !Ref 'RDSClusterAdminSecret'
      TargetId: !Ref 'RDSCluster'
      TargetType: AWS::RDS::DBCluster
    Type: AWS::SecretsManager::SecretTargetAttachment
  RDSClusterErrorLogGroup:
    DependsOn:
      - RDSCluster
    Properties:
      LogGroupName: !Join
        - /
        - - /aws/rds/cluster
          - !Ref 'RDSCluster'
          - error
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  RDSClusterInitializationStarter:
    DependsOn:
      - RDSClusterPrepPolicy
      - RDSInitializationDocument
      - AutomationDocumentStarterLogGroup
    Properties:
      Properties:
        AutomationDocumentName: !Ref 'RDSInitializationDocument'
        EligibleRequestTypes:
          - Create
        ExecutionRoleArn: !GetAtt 'RDSClusterPrepExecutionRole.Arn'
      ServiceToken: !GetAtt 'AutomationDocumentStarterFunction.Arn'
      Type: Custom::StartSSMAutomationDocument
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  RDSClusterInitializationWaiter:
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT15M
    DependsOn:
      - RDSClusterPrepPolicy
      - RDSInitializationDocument
      - AutomationDocumentStarterLogGroup
    Type: AWS::CloudFormation::WaitCondition
  RDSClusterNonAdminSecret:
    Properties:
      Description: !Join
        - ''
        - - 'Non-Admin credentials for '
          - !Ref 'AWS::StackName'
          - ' RDS cluster'
      GenerateSecretString:
        ExcludeCharacters: '"@/\,*!#$%-[]()_:^&`<>;+='''
        ExcludeLowercase: 'false'
        ExcludeNumbers: 'false'
        ExcludePunctuation: 'true'
        ExcludeUppercase: 'false'
        GenerateStringKey: password
        IncludeSpace: 'false'
        PasswordLength: 16
        RequireEachIncludedType: 'true'
        SecretStringTemplate: '{"username": "fixengine"}'
    Type: AWS::SecretsManager::Secret
  RDSClusterNonAdminSecretArnParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'ARN of RDS cluster non-admin secret for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - RDSClusterNonAdminSecretArn
      Tier: Standard
      Type: String
      Value: !Ref 'RDSClusterNonAdminSecret'
    Type: AWS::SSM::Parameter
  RDSClusterNonAdminSecretAttachment:
    DependsOn:
      - RDSCluster
      - RDSClusterNonAdminSecret
    Properties:
      SecretId: !Ref 'RDSClusterNonAdminSecret'
      TargetId: !Ref 'RDSCluster'
      TargetType: AWS::RDS::DBCluster
    Type: AWS::SecretsManager::SecretTargetAttachment
  RDSClusterParameterGroup:
    Properties:
      Description: !Join
        - ''
        - - 'Cluster parameter group for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Family: aurora5.6
      Parameters:
        server_audit_logging: 0
        server_audit_logs_upload: 0
    Type: AWS::RDS::DBClusterParameterGroup
  RDSClusterPrepExecutionRole:
    DependsOn: []
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:RunInstances
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ::image/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :subnet/*
                  - !Join
                    - ''
                    - - 'arn:aws:ec2:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - :security-group/
                      - !GetAtt 'MSKClusterPrepSecurityGroup.GroupId'
              - Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !GetAtt 'RDSClusterPrepInstanceRole.Arn'
              - Action:
                  - cloudformation:SignalResource
                Effect: Allow
                Resource:
                  - !Ref 'AWS::StackId'
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  RDSClusterPrepInstanceRole:
    DependsOn:
      - RDSClusterPrepLogGroup
      - RDSClusterAdminSecret
      - RDSClusterNonAdminSecret
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource:
                  - !Ref 'RDSClusterAdminSecret'
                  - !Ref 'RDSClusterNonAdminSecret'
              - Action:
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                Effect: Allow
                Resource:
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'RDSClusterPrepLogGroup'
                  - !Join
                    - ''
                    - - 'arn:aws:logs:'
                      - !Ref 'AWS::Region'
                      - ':'
                      - !Ref 'AWS::AccountId'
                      - ':log-group:'
                      - !Ref 'RDSClusterPrepLogGroup'
                      - :log-stream:*
          PolicyName: primary-policy
    Type: AWS::IAM::Role
  RDSClusterPrepInstanceRoleProfile:
    DependsOn:
      - RDSClusterPrepInstanceRole
    Properties:
      Path: /
      Roles:
        - !Ref 'RDSClusterPrepInstanceRole'
    Type: AWS::IAM::InstanceProfile
  RDSClusterPrepLogGroup:
    Properties:
      LogGroupName: !Join
        - /
        - - /aws/ssm
          - !Ref 'AWS::StackName'
          - RDSPrepAutomation
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  RDSClusterPrepPolicy:
    DependsOn:
      - AutomationDocumentStarterRole
      - RDSInitializationDocument
      - RDSClusterPrepExecutionRole
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - !GetAtt 'RDSClusterPrepExecutionRole.Arn'
          - Action:
              - ssm:StartAutomationExecution
            Effect: Allow
            Resource:
              - !Join
                - ''
                - - 'arn:aws:ssm:'
                  - !Ref 'AWS::Region'
                  - ':'
                  - !Ref 'AWS::AccountId'
                  - :automation-definition/
                  - !Ref 'RDSInitializationDocument'
                  - :$DEFAULT
      PolicyName: RDSClusterPrepPolicy
      Roles:
        - !Ref 'AutomationDocumentStarterRole'
    Type: AWS::IAM::Policy
  RDSClusterSecretArnParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'ARN of RDS cluster secret for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - RDSClusterSecretArn
      Tier: Standard
      Type: String
      Value: !Ref 'RDSClusterAdminSecret'
    Type: AWS::SSM::Parameter
  RDSClusterSecurityGroup:
    DependsOn:
      - FargateSecurityGroup
    Properties:
      GroupDescription: !Join
        - ''
        - - 'Security Group for '
          - !Ref 'AWS::StackName'
          - ' RDS Cluster'
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/32'
          Description: Deny All Traffic
          FromPort: 1
          IpProtocol: tcp
          ToPort: 1
      SecurityGroupIngress:
        - Description: Fargate Task
          FromPort: 3306
          IpProtocol: tcp
          SourceSecurityGroupId: !Ref 'FargateSecurityGroup'
          ToPort: 3306
        - Description: DB Access for Private User App Ranges
          FromPort: 3306
          IpProtocol: tcp
          SourcePrefixListId: !Ref 'UserApplicationVPCPrefixList'
          ToPort: 3306
      VpcId: !Ref 'VPC'
    Type: AWS::EC2::SecurityGroup
  RDSClusterSubnetGroup:
    DependsOn: []
    Properties:
      DBSubnetGroupDescription: !Join
        - ''
        - - 'Private subnets defined in '
          - !Ref 'AWS::StackName'
          - ' stack'
      SubnetIds:
        - !Ref 'PrimaryPrivateSubnet'
        - !Ref 'FailoverPrivateSubnet'
    Type: AWS::RDS::DBSubnetGroup
  RDSInitializationDocument:
    DependsOn:
      - RDSCluster
      - PrimaryRDSInstance
      - FailoverRDSInstance
      - FargateSecurityGroup
      - RDSClusterPrepLogGroup
      - RDSClusterAdminSecret
      - RDSClusterNonAdminSecret
      - RDSClusterPrepExecutionRole
      - RDSClusterPrepInstanceRoleProfile
    Properties:
      Content:
        assumeRole: '{{ExecutionRoleArn}}'
        description: !Join
          - ''
          - - 'Configure a FIX Engine DB cluster created by CloudFormation stack '
            - !Ref 'AWS::StackName'
        mainSteps:
          - action: aws:runInstances
            inputs:
              IamInstanceProfileName: !Ref 'RDSClusterPrepInstanceRoleProfile'
              ImageId: '{{LatestUbuntu2004AMIId}}'
              InstanceType: t3a.small
              MaxInstanceCount: 1
              MinInstanceCount: 1
              SecurityGroupIds:
                - !Ref 'FargateSecurityGroup'
              SubnetId: !Ref 'PrimaryPrivateSubnet'
              TagSpecifications:
                - ResourceType: instance
                  Tags:
                    - Key: Name
                      Value: !Join
                        - '-'
                        - - !Ref 'AWS::StackName'
                          - RDSInitializer
                    - Key: LaunchedBy
                      Value: SSMAutomation
                    - Key: StackName
                      Value: !Ref 'AWS::StackName'
            maxAttempts: 3
            name: LaunchInstance
            onFailure: step:SignalFailure
            timeoutSeconds: 300
          - action: aws:runCommand
            inputs:
              CloudWatchOutputConfig:
                CloudWatchLogGroupName: !Ref 'RDSClusterPrepLogGroup'
                CloudWatchOutputEnabled: true
              DocumentName: AWS-RunShellScript
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Parameters:
                commands:
                  - sudo apt update
                  - sudo apt install awscli mysql-client jq -y
                  - '#sudo yum install jq mysql -y'
                  - !Join
                    - ''
                    - - DB_HOST=
                      - !GetAtt 'RDSCluster.Endpoint.Address'
                  - '# Retrieves & Assigns to Variables Admin DB Credentials'
                  - !Join
                    - ''
                    - - 'ADMIN_DB_SECRET=$(aws secretsmanager get-secret-value --secret-id '
                      - !Join
                        - '-'
                        - - !Select
                            - 0
                            - !Split
                              - '-'
                              - !Select
                                - 6
                                - !Split
                                  - ':'
                                  - !Ref 'RDSClusterAdminSecret'
                          - !Select
                            - 1
                            - !Split
                              - '-'
                              - !Select
                                - 6
                                - !Split
                                  - ':'
                                  - !Ref 'RDSClusterAdminSecret'
                      - ' --region '
                      - !Ref 'AWS::Region'
                      - ' | jq --raw-output .SecretString)'
                  - ADMIN_DB_USERNAME=$(jq -n -r --argjson data "$ADMIN_DB_SECRET"
                    '$data.username')
                  - export MYSQL_PWD=$(jq -n -r --argjson data "$ADMIN_DB_SECRET"
                    '$data.password')
                  - '# Retrieves & Assigns to Variables Non-Admin DB Credentials'
                  - !Join
                    - ''
                    - - 'NON_ADMIN_DB_SECRET=$(aws secretsmanager get-secret-value
                        --secret-id '
                      - !Join
                        - '-'
                        - - !Select
                            - 0
                            - !Split
                              - '-'
                              - !Select
                                - 6
                                - !Split
                                  - ':'
                                  - !Ref 'RDSClusterNonAdminSecret'
                          - !Select
                            - 1
                            - !Split
                              - '-'
                              - !Select
                                - 6
                                - !Split
                                  - ':'
                                  - !Ref 'RDSClusterNonAdminSecret'
                      - ' --region '
                      - !Ref 'AWS::Region'
                      - ' | jq --raw-output .SecretString)'
                  - NON_ADMIN_DB_USERNAME=$(jq -n -r --argjson data "$NON_ADMIN_DB_SECRET"
                    '$data.username')
                  - NON_ADMIN_DB_PASSWORD=$(jq -n -r --argjson data "$NON_ADMIN_DB_SECRET"
                    '$data.password')
                  - "echo \"\nDROP DATABASE IF EXISTS quickfix;\n\nCREATE DATABASE\
                    \ quickfix;\n\nUSE quickfix;\n\n/* Deletes (if necessary) and\
                    \ Creates Non-Admin User */\nCREATE USER '$NON_ADMIN_DB_USERNAME'\
                    \ IDENTIFIED BY '$NON_ADMIN_DB_PASSWORD';\n\nCREATE TABLE sessions\
                    \ (\n  beginstring CHAR(8) NOT NULL,\n  sendercompid VARCHAR(64)\
                    \ NOT NULL,\n  targetcompid VARCHAR(64) NOT NULL,\n  session_qualifier\
                    \ VARCHAR(64) NOT NULL,\n  creation_time DATETIME NOT NULL,\n\
                    \  incoming_seqnum INT NOT NULL, \n  outgoing_seqnum INT NOT NULL,\n\
                    \  PRIMARY KEY (beginstring, sendercompid, targetcompid, session_qualifier)\n\
                    );\nGRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.sessions\
                    \ TO '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE messages (\n  beginstring\
                    \ CHAR(8) NOT NULL,\n  sendercompid VARCHAR(64) NOT NULL,\n  targetcompid\
                    \ VARCHAR(64) NOT NULL,\n  session_qualifier VARCHAR(64) NOT NULL,\n\
                    \  msgseqnum INT NOT NULL, \n  message BLOB NOT NULL,\n  PRIMARY\
                    \ KEY (beginstring, sendercompid, targetcompid, session_qualifier,\
                    \ msgseqnum)\n);\nGRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.messages\
                    \ TO '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE messages_log (\n\
                    \  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  time DATETIME NOT\
                    \ NULL,\n  time_milliseconds INT NOT NULL,\n  beginstring CHAR(8),\n\
                    \  sendercompid VARCHAR(64),\n  targetcompid VARCHAR(64),\n  session_qualifier\
                    \ VARCHAR(64),\n  text BLOB NOT NULL,\n  PRIMARY KEY (id)\n);\n\
                    GRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.messages_log\
                    \ TO '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE messages_backup_log\
                    \ (\n  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  time DATETIME\
                    \ NOT NULL,\n  time_milliseconds INT NOT NULL,\n  beginstring\
                    \ CHAR(8),\n  sendercompid VARCHAR(64),\n  targetcompid VARCHAR(64),\n\
                    \  session_qualifier VARCHAR(64),\n  text BLOB NOT NULL,\n  PRIMARY\
                    \ KEY (id)\n);\nGRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.messages_backup_log\
                    \ TO '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE event_log (\n \
                    \ id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  time DATETIME NOT\
                    \ NULL,\n  time_milliseconds INT NOT NULL,\n  beginstring CHAR(8),\n\
                    \  sendercompid VARCHAR(64),\n  targetcompid VARCHAR(64),\n  session_qualifier\
                    \ VARCHAR(64),\n  text BLOB NOT NULL,\n  PRIMARY KEY (id)\n);\n\
                    GRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.event_log TO\
                    \ '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE event_backup_log (\n\
                    \  id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  time DATETIME NOT\
                    \ NULL,\n  time_milliseconds INT NOT NULL,\n  beginstring CHAR(8),\n\
                    \  sendercompid VARCHAR(64),\n  targetcompid VARCHAR(64),\n  session_qualifier\
                    \ VARCHAR(64),\n  text BLOB NOT NULL,\n  PRIMARY KEY (id)\n);\n\
                    GRANT SELECT, INSERT, UPDATE, DELETE ON quickfix.event_backup_log\
                    \ TO '$NON_ADMIN_DB_USERNAME';\n\nCREATE TABLE ActiveEngine  (\n\
                    \  TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  ipAddress VARCHAR(16)\
                    \ NOT NULL,\n  PRIMARY KEY (TS, ipAddress)\n);\nGRANT SELECT,\
                    \ UPDATE ON quickfix.ActiveEngine TO '$NON_ADMIN_DB_USERNAME';\n\
                    \nINSERT INTO ActiveEngine VALUES (NOW(), 'none');\n\nDELIMITER\
                    \ //\n\ncreate procedure EngineStatus(IN ipAdd varchar(16), OUT\
                    \ value int, OUT lastIpAdd varchar(16), OUT lastTimestamp DATETIME,\
                    \ OUT timeNow DATETIME, OUT timeDiffSec int)\nBEGIN\n\tSTART TRANSACTION;\n\
                    \    SET timeNow = NOW();\n    SELECT TS, timestampdiff (second,\
                    \ TS, timeNow), ipAddress INTO lastTimestamp, timeDiffSec, lastIpAdd\
                    \ FROM ActiveEngine;\n    IF timeDiffSec <= 3 AND ipAdd != lastIpAdd\
                    \ THEN            # If another IP is the leader and not stale\
                    \ \n      SET value = 0;                                     \
                    \      # Then I do nothing and keep waiting\n    ELSE \n     \
                    \ UPDATE ActiveEngine SET TS = timeNow, ipAddress = ipAdd; # Else\
                    \ I am going to be the leader (update DB to say this) \n     \
                    \ IF (timeDiffSec > 3) THEN                                # \
                    \  If the last leader is stale (no matter if it was me or another\
                    \ IP)\n        SET value = -1;                               \
                    \         #   Then I need to become the new leader\n      ELSE\n\
                    \        SET value = 1;                                      \
                    \   #   Else I am still the active leader\n      END IF;\n   \
                    \ END IF;\n    COMMIT;\nEND //\n\nDELIMITER ;\n\nGRANT SELECT\
                    \ ON mysql.proc TO '$NON_ADMIN_DB_USERNAME';\nGRANT EXECUTE ON\
                    \ PROCEDURE quickfix.EngineStatus TO '$NON_ADMIN_DB_USERNAME';\n\
                    \n\" >> /tmp/rds-cluster-prep.sql"
                  - !Join
                    - ''
                    - - mysql --user $ADMIN_DB_USERNAME --host $DB_HOST --ssl-mode
                        disabled --execute 'source /tmp/rds-cluster-prep.sql'
            name: CreateDBObjects
            onFailure: step:TerminateInstanceOnFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: RDSClusterInitializationWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: SUCCESS
              UniqueId: !Ref 'RDSCluster'
            isEnd: true
            name: SignalSuccess
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: TerminateInstances
              InstanceIds:
                - '{{LaunchInstance.InstanceIds}}'
              Service: ec2
            name: TerminateInstanceOnFailure
            onFailure: step:SignalFailure
          - action: aws:executeAwsApi
            inputs:
              Api: SignalResource
              LogicalResourceId: RDSClusterInitializationWaiter
              Service: cloudformation
              StackName: !Ref 'AWS::StackName'
              Status: FAILURE
              UniqueId: !Ref 'RDSCluster'
            isEnd: true
            name: SignalFailure
        parameters:
          ExecutionRoleArn:
            default: !GetAtt 'RDSClusterPrepExecutionRole.Arn'
            description: The service role to use for this automation.
            type: String
          LatestUbuntu2004AMIId:
            default: '{{ssm:/aws/service/canonical/ubuntu/server/20.04/stable/current/amd64/hvm/ebs-gp2/ami-id}}'
            description: The latest Ubuntu 20.04 LTS AMI queried from the public parameter.
            type: String
        schemaVersion: '0.3'
      DocumentType: Automation
    Type: AWS::SSM::Document
  RDSParameterGroup:
    Properties:
      Description: !Join
        - ''
        - - 'Parameter group for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Family: aurora5.6
      Parameters:
        long_query_time: 5
        slow_query_log: 1
    Type: AWS::RDS::DBParameterGroup
  Route53HealthCheckVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      Entries:
        - Cidr: 15.177.0.0/18
          Description: AWS:ROUTE53_HEALTHCHECKS:GLOBAL
        - Cidr: 52.80.197.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.80.197.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.80.198.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-north-1
        - Cidr: 52.83.34.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 52.83.35.0/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 52.83.35.128/25
          Description: AWS:ROUTE53_HEALTHCHECKS:cn-northwest-1
        - Cidr: 54.248.220.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-northeast-1
        - Cidr: 54.250.253.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-northeast-1
        - Cidr: 54.251.31.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-1
        - Cidr: 54.255.254.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-1
        - Cidr: 54.252.254.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-2
        - Cidr: 54.252.79.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:ap-southeast-2
        - Cidr: 176.34.159.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:eu-west-1
        - Cidr: 54.228.16.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:eu-west-1
        - Cidr: 177.71.207.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:sa-east-1
        - Cidr: 54.232.40.64/26
          Description: AWS:ROUTE53_HEALTHCHECKS:sa-east-1
        - Cidr: 107.23.255.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-east-1
        - Cidr: 54.243.31.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-east-1
        - Cidr: 54.183.255.128/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-1
        - Cidr: 54.241.32.64/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-1
        - Cidr: 54.244.52.192/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-2
        - Cidr: 54.245.168.0/26
          Description: AWS:ROUTE53_HEALTHCHECKS:us-west-2
      MaxEntries: 30
      PrefixListName: AWS:Route53HealthChecks
    Type: AWS::EC2::PrefixList
  SenderCompIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine sender computer ID defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - SenderCompID
      Tier: Standard
      Type: String
      Value: !Ref 'SenderCompID'
    Type: AWS::SSM::Parameter
  StackNameManipulator:
    DependsOn:
      - MiscMethodsHandlerLogGroup
    Properties:
      Properties:
        Action: lower
        InputString: !Ref 'AWS::StackName'
      ServiceToken: !GetAtt 'MiscMethodsHandlerFunction.Arn'
      Type: Custom::ManipulateString
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  TargetCompIDParam:
    Condition: ''
    Properties:
      Description: !Join
        - ''
        - - 'FIX engine target computer ID defined in the parameters of the '
          - !Ref 'AWS::StackName'
          - ' stack'
      Name: !Join
        - /
        - - /fixengine
          - !Ref 'AWS::StackName'
          - TargetCompID
      Tier: Standard
      Type: String
      Value: !Ref 'TargetCompID'
    Type: AWS::SSM::Parameter
  UserApplicationPrefixListUpdater:
    DependsOn:
      - UserApplicationVPCPrefixList
      - VPCPrefixListManagerLogGroup
    Properties:
      Properties:
        AuthorizedCidrs: !Ref 'UserApplicationCIDRs'
        EntryDescription: !Join
          - ''
          - - 'Authorized User Application CIDR in '
            - !Ref 'AWS::StackName'
            - ' stack'
        PrefixListId: !Ref 'UserApplicationVPCPrefixList'
      ServiceToken: !GetAtt 'VPCPrefixListManagerFunction.Arn'
      Type: Custom::UpdateUserApplicationPrefixList
      Version: '1.0'
    Type: AWS::CloudFormation::CustomResource
  UserApplicationVPCPrefixList:
    Properties:
      AddressFamily: IPv4
      MaxEntries: 5
      PrefixListName: !Join
        - ''
        - - !Ref 'AWS::StackName'
          - '-'
          - UserAppCIDRs
    Type: AWS::EC2::PrefixList
  VPCPrefixListManagerFunction:
    Condition: ''
    DependsOn:
      - VPCPrefixListManagerRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: This function is only invoked during the deployment of this solution,
              potentially PRIOR to the creation of a VPC, and is never used again.
          - id: W92
            reason: This function is only invoked during the deployment of this solution
              and is never used again. Reserving concurrency would therefore be wasteful.
    Properties:
      Code:
        ZipFile: "import json\nimport boto3\nimport logging\nimport cfnresponse\n\
          from botocore.exceptions import ClientError\n\nLOGGER = logging.getLogger()\n\
          LOGGER.setLevel(logging.INFO)\nlogging.getLogger('boto3').setLevel(logging.INFO)\n\
          logging.getLogger('botocore').setLevel(logging.INFO)\n\n'''\n    - PrefixListId\
          \ | str\n    - AuthorizedCidrs | list\n    - EntryDescription | str\n'''\n\
          def handler(event, context):\n\n    LOGGER.info('----- REQUEST RECEIVED\
          \ -----')\n    LOGGER.info(json.dumps(event))\n\n    responseData = {}\n\
          \    \n    operation = event['ResourceProperties']['Type'].split('Custom::')[1]\n\
          \    properties = event['ResourceProperties']['Properties']\n    \n    #\
          \ If the Stack is Being Created or Updated\n    if event['RequestType']\
          \ in ['Create', 'Update']:\n        \n        ec2_client = boto3.client('ec2')\n\
          \        \n        try:\n            \n            prefix_list = ec2_client.describe_managed_prefix_lists(\n\
          \                PrefixListIds = [\n                    properties['PrefixListId']\n\
          \                ]\n            )\n            \n            if len(prefix_list['PrefixLists'])\
          \ == 0:\n                print('Prefix List w/ ID: ' + properties['PrefixListId']\
          \ + ' Could Not be Found')\n                return cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, responseData)\n                \n       \
          \     else:\n                prefix_list = prefix_list['PrefixLists'][0]\n\
          \                \n            existing_entries = ec2_client.get_managed_prefix_list_entries(\n\
          \                PrefixListId = prefix_list['PrefixListId'],\n         \
          \   )\n        \n        except ClientError as e:\n            print(str(e))\n\
          \            return cfnresponse.send(event, context, cfnresponse.FAILED,\
          \ responseData)\n            \n        new_entries = properties['AuthorizedCidrs']\n\
          \        \n        entries_to_add = []\n        entries_to_remove = []\n\
          \        \n        # If There Are Existing Entries\n        if len(existing_entries['Entries'])\
          \ > 0:\n            \n            # For Each Existing Entry\n          \
          \  for existing_entry in existing_entries['Entries']:\n                \n\
          \                # If the CIDR is No Longer Authorized\n               \
          \ if existing_entry['Cidr'] not in new_entries:\n                    \n\
          \                    # We'll Queue it for Removal\n                    entries_to_remove.append({\n\
          \                        'Cidr': existing_entry['Cidr']\n              \
          \      })\n                \n                # Else, We'll Remove it from\
          \ our \"New Entries\" List\n                else:\n                    new_entries.remove(existing_entry['Cidr'])\n\
          \        \n        # For Each New Entry Remaining\n        for new_entry\
          \ in new_entries:\n            \n            # We'll Format its Input\n\
          \            entries_to_add.append({\n                'Cidr': new_entry,\n\
          \                'Description': properties['EntryDescription'],\n      \
          \      })\n        \n        # If There's at Least 1 Entry to Add or Remove\n\
          \        if len(entries_to_add) > 0 or len(entries_to_remove) > 0:\n   \
          \         \n            try:\n                \n                # We'll\
          \ Try to Update the List\n                ec2_client.modify_managed_prefix_list(\n\
          \                    PrefixListId = prefix_list['PrefixListId'],\n     \
          \               CurrentVersion = prefix_list['Version'],\n             \
          \       AddEntries = entries_to_add,\n                    RemoveEntries\
          \ = entries_to_remove,\n                )\n                \n          \
          \  except ClientError as e:\n                print(str(e))\n           \
          \     return cfnresponse.send(event, context, cfnresponse.FAILED, responseData)\n\
          \        \n        return cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData, properties['PrefixListId'])\n    \n    # If the Stack is\
          \ Being Deleted   \n    elif event['RequestType'] in ['Delete']:\n     \
          \   \n        # CFN Can Delete Prefix Lists Containing Entries, So There's\
          \ Nothing For Us to Do\n        return cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, responseData)"
      Description: !Join
        - ''
        - - 'VPCPrefixListManager resource for '
          - !Ref 'AWS::StackName'
          - ' stack'
      Handler: index.handler
      Role: !GetAtt 'VPCPrefixListManagerRole.Arn'
      Runtime: python3.7
      Timeout: 15
    Type: AWS::Lambda::Function
  VPCPrefixListManagerLogGroup:
    Condition: ''
    DependsOn:
      - VPCPrefixListManagerFunction
    Properties:
      LogGroupName: !Join
        - ''
        - - /aws/lambda/
          - !Ref 'VPCPrefixListManagerFunction'
      RetentionInDays: !Ref 'LogRetentionInDays'
    Type: AWS::Logs::LogGroup
  VPCPrefixListManagerRole:
    Condition: ''
    DependsOn: []
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: ec2:DescribeManagedPrefixLists does not support resource filtering.
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - ec2:DescribeManagedPrefixLists
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - ec2:ModifyManagedPrefixList
                  - ec2:GetManagedPrefixListEntries
                Effect: Allow
                Resource:
                  - !GetAtt 'FIXClientVPCPrefixList.Arn'
                  - !GetAtt 'UserApplicationVPCPrefixList.Arn'
          PolicyName: PrimaryPolicy
    Type: AWS::IAM::Role
